e0f337c04e6cea3fc65089dfa7cb6803
"use strict";
var _a, _b;
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuthService = void 0;
const tslib_1 = require("tslib");
const common_1 = require("@nestjs/common");
const core_supabase_1 = require("@visapi/core-supabase");
const core_config_1 = require("@visapi/core-config");
const bcrypt = tslib_1.__importStar(require("bcrypt"));
const crypto_1 = require("crypto");
let AuthService = class AuthService {
    constructor(supabase, config) {
        this.supabase = supabase;
        this.config = config;
    }
    createApiKey(name, scopes, createdBy) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Generate prefix and secret
            const prefix = this.config.apiKeyPrefix || 'vapi_';
            const secret = (0, crypto_1.randomBytes)(32).toString('hex');
            const fullKey = `${prefix}${secret}`;
            // Hash only the secret part for storage
            const hashedSecret = yield bcrypt.hash(secret, 12);
            // Calculate expiry date
            const expiresAt = new Date();
            expiresAt.setDate(expiresAt.getDate() + (this.config.apiKeyExpiryDays || 90));
            // Store in database
            const { data, error } = yield this.supabase.serviceClient
                .from('api_keys')
                .insert({
                name,
                prefix,
                hashed_secret: hashedSecret,
                scopes,
                expires_at: expiresAt.toISOString(),
                created_by: createdBy,
            })
                .select()
                .single();
            if (error) {
                throw new Error(`Failed to create API key: ${error.message}`);
            }
            return {
                key: fullKey,
                apiKey: data,
            };
        });
    }
    validateApiKey(apiKey) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { prefix, secret } = this.splitApiKey(apiKey);
            if (!prefix || !secret) {
                return null;
            }
            // Find the API key record by prefix
            const { data, error } = yield this.supabase.serviceClient
                .from('api_keys')
                .select('*')
                .eq('prefix', prefix)
                .single();
            if (error || !data) {
                return null;
            }
            // Check if expired
            if (data.expires_at && new Date(data.expires_at) < new Date()) {
                return null;
            }
            // Use bcrypt.compare to validate the secret
            const isValid = yield bcrypt.compare(secret, data.hashed_secret);
            if (!isValid) {
                return null;
            }
            // Update last_used_at timestamp
            yield this.supabase.serviceClient
                .from('api_keys')
                .update({ last_used_at: new Date().toISOString() })
                .eq('id', data.id);
            return data;
        });
    }
    listApiKeys(userId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let query = this.supabase.serviceClient
                .from('api_keys')
                .select('*')
                .order('created_at', { ascending: false });
            if (userId) {
                query = query.eq('created_by', userId);
            }
            const { data, error } = yield query;
            if (error) {
                throw new Error(`Failed to list API keys: ${error.message}`);
            }
            return data || [];
        });
    }
    revokeApiKey(keyId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { error } = yield this.supabase.serviceClient
                .from('api_keys')
                .delete()
                .eq('id', keyId);
            if (error) {
                throw new Error(`Failed to revoke API key: ${error.message}`);
            }
        });
    }
    splitApiKey(apiKey) {
        const prefixPattern = this.config.apiKeyPrefix || 'vapi_';
        if (!apiKey.startsWith(prefixPattern)) {
            return { prefix: '', secret: '' };
        }
        const prefix = prefixPattern;
        const secret = apiKey.slice(prefix.length);
        return { prefix, secret };
    }
    checkScopes(apiKey, requiredScopes) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!requiredScopes.length) {
                return true;
            }
            return requiredScopes.every((scope) => apiKey.scopes.includes(scope));
        });
    }
};
exports.AuthService = AuthService;
exports.AuthService = AuthService = tslib_1.__decorate([
    (0, common_1.Injectable)(),
    tslib_1.__metadata("design:paramtypes", [typeof (_a = typeof core_supabase_1.SupabaseService !== "undefined" && core_supabase_1.SupabaseService) === "function" ? _a : Object, typeof (_b = typeof core_config_1.ConfigService !== "undefined" && core_config_1.ConfigService) === "function" ? _b : Object])
], AuthService);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL3ZhZGltL1Byb2plY3RzL1Zpc0FQSS9hcHBzL2JhY2tlbmQvc3JjL2F1dGgvYXV0aC5zZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsMkNBQTRDO0FBQzVDLHlEQUF3RDtBQUN4RCxxREFBb0Q7QUFFcEQsdURBQWlDO0FBQ2pDLG1DQUFxQztBQUc5QixJQUFNLFdBQVcsR0FBakIsTUFBTSxXQUFXO0lBQ3RCLFlBQ21CLFFBQXlCLEVBQ3pCLE1BQXFCO1FBRHJCLGFBQVEsR0FBUixRQUFRLENBQWlCO1FBQ3pCLFdBQU0sR0FBTixNQUFNLENBQWU7SUFDckMsQ0FBQztJQUVFLFlBQVksQ0FDaEIsSUFBWSxFQUNaLE1BQWdCLEVBQ2hCLFNBQWlCOztZQUVqQiw2QkFBNkI7WUFDN0IsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxZQUFZLElBQUksT0FBTyxDQUFDO1lBQ25ELE1BQU0sTUFBTSxHQUFHLElBQUEsb0JBQVcsRUFBQyxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDL0MsTUFBTSxPQUFPLEdBQUcsR0FBRyxNQUFNLEdBQUcsTUFBTSxFQUFFLENBQUM7WUFFckMsd0NBQXdDO1lBQ3hDLE1BQU0sWUFBWSxHQUFHLE1BQU0sTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFFbkQsd0JBQXdCO1lBQ3hCLE1BQU0sU0FBUyxHQUFHLElBQUksSUFBSSxFQUFFLENBQUM7WUFDN0IsU0FBUyxDQUFDLE9BQU8sQ0FDZixTQUFTLENBQUMsT0FBTyxFQUFFLEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLGdCQUFnQixJQUFJLEVBQUUsQ0FBQyxDQUMzRCxDQUFDO1lBRUYsb0JBQW9CO1lBQ3BCLE1BQU0sRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLEdBQUcsTUFBTSxJQUFJLENBQUMsUUFBUSxDQUFDLGFBQWE7aUJBQ3RELElBQUksQ0FBQyxVQUFVLENBQUM7aUJBQ2hCLE1BQU0s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LElBQUEsbUJBQVUsR0FBRTtpRUFHa0IsK0JBQWUsb0JBQWYsK0JBQWUsb0RBQ2pCLDJCQUFhLG9CQUFiLDJCQUFhO0dBSDdCLFdBQVcsQ0EySXZCIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy92YWRpbS9Qcm9qZWN0cy9WaXNBUEkvYXBwcy9iYWNrZW5kL3NyYy9hdXRoL2F1dGguc2VydmljZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQG5lc3Rqcy9jb21tb24nO1xuaW1wb3J0IHsgU3VwYWJhc2VTZXJ2aWNlIH0gZnJvbSAnQHZpc2FwaS9jb3JlLXN1cGFiYXNlJztcbmltcG9ydCB7IENvbmZpZ1NlcnZpY2UgfSBmcm9tICdAdmlzYXBpL2NvcmUtY29uZmlnJztcbmltcG9ydCB7IEFwaUtleVJlY29yZCB9IGZyb20gJ0B2aXNhcGkvc2hhcmVkLXR5cGVzJztcbmltcG9ydCAqIGFzIGJjcnlwdCBmcm9tICdiY3J5cHQnO1xuaW1wb3J0IHsgcmFuZG9tQnl0ZXMgfSBmcm9tICdjcnlwdG8nO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgQXV0aFNlcnZpY2Uge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IHN1cGFiYXNlOiBTdXBhYmFzZVNlcnZpY2UsXG4gICAgcHJpdmF0ZSByZWFkb25seSBjb25maWc6IENvbmZpZ1NlcnZpY2VcbiAgKSB7fVxuXG4gIGFzeW5jIGNyZWF0ZUFwaUtleShcbiAgICBuYW1lOiBzdHJpbmcsXG4gICAgc2NvcGVzOiBzdHJpbmdbXSxcbiAgICBjcmVhdGVkQnk6IHN0cmluZ1xuICApOiBQcm9taXNlPHsga2V5OiBzdHJpbmc7IGFwaUtleTogQXBpS2V5UmVjb3JkIH0+IHtcbiAgICAvLyBHZW5lcmF0ZSBwcmVmaXggYW5kIHNlY3JldFxuICAgIGNvbnN0IHByZWZpeCA9IHRoaXMuY29uZmlnLmFwaUtleVByZWZpeCB8fCAndmFwaV8nO1xuICAgIGNvbnN0IHNlY3JldCA9IHJhbmRvbUJ5dGVzKDMyKS50b1N0cmluZygnaGV4Jyk7XG4gICAgY29uc3QgZnVsbEtleSA9IGAke3ByZWZpeH0ke3NlY3JldH1gO1xuXG4gICAgLy8gSGFzaCBvbmx5IHRoZSBzZWNyZXQgcGFydCBmb3Igc3RvcmFnZVxuICAgIGNvbnN0IGhhc2hlZFNlY3JldCA9IGF3YWl0IGJjcnlwdC5oYXNoKHNlY3JldCwgMTIpO1xuXG4gICAgLy8gQ2FsY3VsYXRlIGV4cGlyeSBkYXRlXG4gICAgY29uc3QgZXhwaXJlc0F0ID0gbmV3IERhdGUoKTtcbiAgICBleHBpcmVzQXQuc2V0RGF0ZShcbiAgICAgIGV4cGlyZXNBdC5nZXREYXRlKCkgKyAodGhpcy5jb25maWcuYXBpS2V5RXhwaXJ5RGF5cyB8fCA5MClcbiAgICApO1xuXG4gICAgLy8gU3RvcmUgaW4gZGF0YWJhc2VcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCB0aGlzLnN1cGFiYXNlLnNlcnZpY2VDbGllbnRcbiAgICAgIC5mcm9tKCdhcGlfa2V5cycpXG4gICAgICAuaW5zZXJ0KHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgcHJlZml4LFxuICAgICAgICBoYXNoZWRfc2VjcmV0OiBoYXNoZWRTZWNyZXQsXG4gICAgICAgIHNjb3BlcyxcbiAgICAgICAgZXhwaXJlc19hdDogZXhwaXJlc0F0LnRvSVNPU3RyaW5nKCksXG4gICAgICAgIGNyZWF0ZWRfYnk6IGNyZWF0ZWRCeSxcbiAgICAgIH0pXG4gICAgICAuc2VsZWN0KClcbiAgICAgIC5zaW5nbGUoKTtcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIEFQSSBrZXk6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAga2V5OiBmdWxsS2V5LFxuICAgICAgYXBpS2V5OiBkYXRhLFxuICAgIH07XG4gIH1cblxuICBhc3luYyB2YWxpZGF0ZUFwaUtleShhcGlLZXk6IHN0cmluZyk6IFByb21pc2U8QXBpS2V5UmVjb3JkIHwgbnVsbD4ge1xuICAgIGNvbnN0IHsgcHJlZml4LCBzZWNyZXQgfSA9IHRoaXMuc3BsaXRBcGlLZXkoYXBpS2V5KTtcbiAgICBpZiAoIXByZWZpeCB8fCAhc2VjcmV0KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBGaW5kIHRoZSBBUEkga2V5IHJlY29yZCBieSBwcmVmaXhcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCB0aGlzLnN1cGFiYXNlLnNlcnZpY2VDbGllbnRcbiAgICAgIC5mcm9tKCdhcGlfa2V5cycpXG4gICAgICAuc2VsZWN0KCcqJylcbiAgICAgIC5lcSgncHJlZml4JywgcHJlZml4KVxuICAgICAgLnNpbmdsZSgpO1xuXG4gICAgaWYgKGVycm9yIHx8ICFkYXRhKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBleHBpcmVkXG4gICAgaWYgKGRhdGEuZXhwaXJlc19hdCAmJiBuZXcgRGF0ZShkYXRhLmV4cGlyZXNfYXQpIDwgbmV3IERhdGUoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gVXNlIGJjcnlwdC5jb21wYXJlIHRvIHZhbGlkYXRlIHRoZSBzZWNyZXRcbiAgICBjb25zdCBpc1ZhbGlkID0gYXdhaXQgYmNyeXB0LmNvbXBhcmUoc2VjcmV0LCBkYXRhLmhhc2hlZF9zZWNyZXQpO1xuICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIGxhc3RfdXNlZF9hdCB0aW1lc3RhbXBcbiAgICBhd2FpdCB0aGlzLnN1cGFiYXNlLnNlcnZpY2VDbGllbnRcbiAgICAgIC5mcm9tKCdhcGlfa2V5cycpXG4gICAgICAudXBkYXRlKHsgbGFzdF91c2VkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgfSlcbiAgICAgIC5lcSgnaWQnLCBkYXRhLmlkKTtcblxuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgYXN5bmMgbGlzdEFwaUtleXModXNlcklkPzogc3RyaW5nKTogUHJvbWlzZTxBcGlLZXlSZWNvcmRbXT4ge1xuICAgIGxldCBxdWVyeSA9IHRoaXMuc3VwYWJhc2Uuc2VydmljZUNsaWVudFxuICAgICAgLmZyb20oJ2FwaV9rZXlzJylcbiAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgLm9yZGVyKCdjcmVhdGVkX2F0JywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pO1xuXG4gICAgaWYgKHVzZXJJZCkge1xuICAgICAgcXVlcnkgPSBxdWVyeS5lcSgnY3JlYXRlZF9ieScsIHVzZXJJZCk7XG4gICAgfVxuXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgcXVlcnk7XG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxpc3QgQVBJIGtleXM6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YSB8fCBbXTtcbiAgfVxuXG4gIGFzeW5jIHJldm9rZUFwaUtleShrZXlJZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgdGhpcy5zdXBhYmFzZS5zZXJ2aWNlQ2xpZW50XG4gICAgICAuZnJvbSgnYXBpX2tleXMnKVxuICAgICAgLmRlbGV0ZSgpXG4gICAgICAuZXEoJ2lkJywga2V5SWQpO1xuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byByZXZva2UgQVBJIGtleTogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc3BsaXRBcGlLZXkoYXBpS2V5OiBzdHJpbmcpOiB7IHByZWZpeDogc3RyaW5nOyBzZWNyZXQ6IHN0cmluZyB9IHtcbiAgICBjb25zdCBwcmVmaXhQYXR0ZXJuID0gdGhpcy5jb25maWcuYXBpS2V5UHJlZml4IHx8ICd2YXBpXyc7XG5cbiAgICBpZiAoIWFwaUtleS5zdGFydHNXaXRoKHByZWZpeFBhdHRlcm4pKSB7XG4gICAgICByZXR1cm4geyBwcmVmaXg6ICcnLCBzZWNyZXQ6ICcnIH07XG4gICAgfVxuXG4gICAgY29uc3QgcHJlZml4ID0gcHJlZml4UGF0dGVybjtcbiAgICBjb25zdCBzZWNyZXQgPSBhcGlLZXkuc2xpY2UocHJlZml4Lmxlbmd0aCk7XG5cbiAgICByZXR1cm4geyBwcmVmaXgsIHNlY3JldCB9O1xuICB9XG5cbiAgYXN5bmMgY2hlY2tTY29wZXMoXG4gICAgYXBpS2V5OiBBcGlLZXlSZWNvcmQsXG4gICAgcmVxdWlyZWRTY29wZXM6IHN0cmluZ1tdXG4gICk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGlmICghcmVxdWlyZWRTY29wZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVxdWlyZWRTY29wZXMuZXZlcnkoKHNjb3BlKSA9PiBhcGlLZXkuc2NvcGVzLmluY2x1ZGVzKHNjb3BlKSk7XG4gIH1cbn1cbiJdLCJ2ZXJzaW9uIjozfQ==