{"file":"/Users/vadim/Projects/VisAPI/libs/backend/util-redis/src/lib/idempotency.service.ts","mappings":"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","names":[],"sources":["/Users/vadim/Projects/VisAPI/libs/backend/util-redis/src/lib/idempotency.service.ts"],"sourcesContent":["import { Injectable, Inject } from '@nestjs/common';\nimport { Logger } from '@nestjs/common';\nimport { randomUUID } from 'crypto';\n\n// Redis client interface - to be injected\nexport interface RedisClient {\n  get(key: string): Promise<string | null>;\n  set(\n    key: string,\n    value: string,\n    mode?: string,\n    duration?: number,\n    flag?: string\n  ): Promise<string | null>;\n  setex(key: string, seconds: number, value: string): Promise<string>;\n  del(key: string): Promise<number>;\n  expire(key: string, seconds: number): Promise<number>;\n  eval(script: string, numKeys: number, ...args: string[]): Promise<any>;\n}\n\n@Injectable()\nexport class IdempotencyService {\n  private readonly logger = new Logger(IdempotencyService.name);\n\n  constructor(@Inject('REDIS_CLIENT') private readonly redis: RedisClient) {}\n\n  /**\n   * Check if an idempotency key has already been processed and return cached result\n   */\n  private async checkIdempotency(key: string): Promise<any> {\n    try {\n      const cachedResult = await this.redis.get(`idempotent:${key}`);\n      return cachedResult ? JSON.parse(cachedResult) : null;\n    } catch (error) {\n      this.logger.warn(`Failed to check idempotency for key ${key}:`, error);\n      return null;\n    }\n  }\n\n  /**\n   * Store the result of an idempotent operation\n   */\n  private async storeResult(\n    key: string,\n    result: any,\n    ttl: number = 3600\n  ): Promise<void> {\n    try {\n      await this.redis.setex(\n        `idempotent:${key}`,\n        ttl,\n        JSON.stringify({\n          result,\n          timestamp: Date.now(),\n          status: 'completed',\n        })\n      );\n      this.logger.debug(`Stored idempotent result for key: ${key}`);\n    } catch (error) {\n      this.logger.warn(\n        `Failed to store idempotent result for key ${key}:`,\n        error\n      );\n    }\n  }\n\n  /**\n   * Execute an operation with idempotency protection\n   */\n  async checkAndExecute<T>(\n    key: string,\n    executor: () => Promise<T>,\n    ttl: number = 3600\n  ): Promise<T> {\n    const lockKey = `idempotent:${key}:lock`;\n    const resultKey = `idempotent:${key}:result`;\n\n    // Check if result already exists\n    const existingResult = await this.redis.get(resultKey);\n    if (existingResult) {\n      this.logger.debug(`Returning cached idempotent result for key: ${key}`);\n      const parsed = JSON.parse(existingResult);\n      return parsed.result;\n    }\n\n    // Try to acquire lock\n    const lockId = randomUUID();\n    const lockAcquired = await this.redis.set(\n      lockKey,\n      lockId,\n      'PX',\n      300000,\n      'NX'\n    );\n\n    if (lockAcquired !== 'OK') {\n      // Another request is processing, wait and check for result\n      await this.waitForResult(resultKey, 30000); // Wait up to 30 seconds\n      const result = await this.redis.get(resultKey);\n      if (result) {\n        const parsed = JSON.parse(result);\n        return parsed.result;\n      }\n      throw new Error('Idempotent operation failed - no result available');\n    }\n\n    try {\n      // Execute the operation\n      this.logger.debug(`Executing idempotent operation for key: ${key}`);\n      const result = await executor();\n\n      // Store result\n      await this.storeResult(key, result, ttl);\n\n      return result;\n    } finally {\n      // Release lock\n      await this.releaseLock(lockKey, lockId);\n    }\n  }\n\n  /**\n   * Mark an operation as in progress to prevent concurrent execution\n   */\n  private async markInProgress(key: string, ttl: number = 300): Promise<boolean> {\n    try {\n      const success = await this.redis.set(\n        `idempotent:${key}:lock`,\n        'processing',\n        'PX',\n        ttl * 1000,\n        'NX'\n      );\n      return success === 'OK';\n    } catch (error) {\n      this.logger.warn(\n        `Failed to mark operation as in progress for key ${key}:`,\n        error\n      );\n      return false;\n    }\n  }\n\n  /**\n   * Wait for a result to become available (polling with backoff)\n   */\n  private async waitForResult(\n    resultKey: string,\n    maxWaitMs: number\n  ): Promise<void> {\n    const startTime = Date.now();\n    let delay = 100; // Start with 100ms delay\n\n    while (Date.now() - startTime < maxWaitMs) {\n      const result = await this.redis.get(resultKey);\n      if (result) {\n        return;\n      }\n\n      await new Promise((resolve) => setTimeout(resolve, delay));\n      delay = Math.min(delay * 1.5, 2000); // Exponential backoff, max 2s\n    }\n  }\n\n  /**\n   * Release a distributed lock using Lua script for atomicity\n   */\n  private async releaseLock(lockKey: string, lockId: string): Promise<boolean> {\n    try {\n      const script = `\n        if redis.call(\"get\", KEYS[1]) == ARGV[1] then\n          return redis.call(\"del\", KEYS[1])\n        else\n          return 0\n        end\n      `;\n      const result = await this.redis.eval(script, 1, lockKey, lockId);\n      return result === 1;\n    } catch (error) {\n      this.logger.warn(`Failed to release lock ${lockKey}:`, error);\n      return false;\n    }\n  }\n\n  /**\n   * Clear an idempotency key (for testing or manual cleanup)\n   */\n  async clearIdempotencyKey(key: string): Promise<void> {\n    try {\n      await this.redis.del(`idempotent:${key}`);\n      await this.redis.del(`idempotent:${key}:lock`);\n      await this.redis.del(`idempotent:${key}:result`);\n      this.logger.debug(`Cleared idempotency key: ${key}`);\n    } catch (error) {\n      this.logger.warn(`Failed to clear idempotency key ${key}:`, error);\n    }\n  }\n}\n"],"version":3}