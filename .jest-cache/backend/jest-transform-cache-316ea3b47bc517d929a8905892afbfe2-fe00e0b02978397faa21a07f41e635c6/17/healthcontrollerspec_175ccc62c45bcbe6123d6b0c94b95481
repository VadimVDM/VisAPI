993f9528307806a13eb8c5b1e337727e
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const testing_1 = require("@nestjs/testing");
const health_controller_1 = require("./health.controller");
const terminus_1 = require("@nestjs/terminus");
const redis_health_1 = require("./indicators/redis.health");
const supabase_health_1 = require("./indicators/supabase.health");
describe('HealthController', () => {
    let controller;
    let healthCheckService;
    let redisHealth;
    let supabaseHealth;
    const mockHealthCheckService = {
        check: jest.fn(),
    };
    beforeEach(() => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        const module = yield testing_1.Test.createTestingModule({
            imports: [terminus_1.TerminusModule],
            controllers: [health_controller_1.HealthController],
            providers: [
                {
                    provide: terminus_1.HealthCheckService,
                    useValue: mockHealthCheckService,
                },
                {
                    provide: redis_health_1.RedisHealthIndicator,
                    useValue: {
                        isHealthy: jest.fn(),
                    },
                },
                {
                    provide: supabase_health_1.SupabaseHealthIndicator,
                    useValue: {
                        isHealthy: jest.fn(),
                    },
                },
            ],
        }).compile();
        controller = module.get(health_controller_1.HealthController);
        healthCheckService = module.get(terminus_1.HealthCheckService);
        redisHealth = module.get(redis_health_1.RedisHealthIndicator);
        supabaseHealth = module.get(supabase_health_1.SupabaseHealthIndicator);
    }));
    afterEach(() => {
        jest.clearAllMocks();
    });
    it('should be defined', () => {
        expect(controller).toBeDefined();
    });
    describe('check', () => {
        it('should return healthy status when all services are up', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const mockHealthResult = {
                status: 'ok',
                info: {
                    redis: {
                        status: 'up',
                    },
                    database: {
                        status: 'up',
                    },
                },
                error: {},
                details: {
                    redis: {
                        status: 'up',
                    },
                    database: {
                        status: 'up',
                    },
                },
            };
            mockHealthCheckService.check.mockResolvedValue(mockHealthResult);
            const result = yield controller.check();
            expect(result).toEqual(mockHealthResult);
            expect(mockHealthCheckService.check).toHaveBeenCalledWith([
                expect.any(Function),
                expect.any(Function),
            ]);
        }));
        it('should return error status when services are down', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const mockHealthResult = {
                status: 'error',
                info: {},
                error: {
                    redis: {
                        status: 'down',
                        message: 'Connection refused',
                    },
                    database: {
                        status: 'down',
                        message: 'Timeout',
                    },
                },
                details: {
                    redis: {
                        status: 'down',
                        message: 'Connection refused',
                    },
                    database: {
                        status: 'down',
                        message: 'Timeout',
                    },
                },
            };
            mockHealthCheckService.check.mockRejectedValue({
                response: mockHealthResult,
            });
            yield expect(controller.check()).rejects.toMatchObject({
                response: mockHealthResult,
            });
        }));
    });
    describe('liveness', () => {
        it('should return ok status for liveness probe', () => {
            const result = controller.liveness();
            expect(result).toEqual({
                status: 'ok',
                timestamp: expect.any(String),
            });
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL3ZhZGltL1Byb2plY3RzL1Zpc0FQSS9hcHBzL2JhY2tlbmQvc3JjL2hlYWx0aC9oZWFsdGguY29udHJvbGxlci5zcGVjLnRzIiwibWFwcGluZ3MiOiI7OztBQUFBLDZDQUFzRDtBQUN0RCwyREFBdUQ7QUFDdkQsK0NBRzBCO0FBQzFCLDREQUFpRTtBQUNqRSxrRUFBdUU7QUFFdkUsUUFBUSxDQUFDLGtCQUFrQixFQUFFLEdBQUcsRUFBRTtJQUNoQyxJQUFJLFVBQTRCLENBQUM7SUFDakMsSUFBSSxrQkFBbUQsQ0FBQztJQUN4RCxJQUFJLFdBQThDLENBQUM7SUFDbkQsSUFBSSxjQUFvRCxDQUFDO0lBRXpELE1BQU0sc0JBQXNCLEdBQUc7UUFDN0IsS0FBSyxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUU7S0FDakIsQ0FBQztJQUVGLFVBQVUsQ0FBQyxHQUFTLEVBQUU7UUFDcEIsTUFBTSxNQUFNLEdBQWtCLE1BQU0sY0FBSSxDQUFDLG1CQUFtQixDQUFDO1lBQzNELE9BQU8sRUFBRSxDQUFDLHlCQUFjLENBQUM7WUFDekIsV0FBVyxFQUFFLENBQUMsb0NBQWdCLENBQUM7WUFDL0IsU0FBUyxFQUFFO2dCQUNUO29CQUNFLE9BQU8sRUFBRSw2QkFBa0I7b0JBQzNCLFFBQVEsRUFBRSxzQkFBc0I7aUJBQ2pDO2dCQUNEO29CQUNFLE9BQU8sRUFBRSxtQ0FBb0I7b0JBQzdCLFFBQVEsRUFBRTt3QkFDUixTQUFTLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRTtxQkFDckI7aUJBQ0Y7Z0JBQ0Q7b0JBQ0UsT0FBTyxFQUFFLHlDQUF1QjtvQkFDaEMsUUFBUSxFQUFFO3dCQUNSLFNBQVMsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO3FCQUNyQjtpQkFDRjthQUNGO1NBQ0YsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBRWIsVUFBVSxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQW1CLG9DQUFnQixDQUFDLENBQUM7UUFDNUQsa0JBQWtCLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBQyw2QkFB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LEVBQUUsQ0FBQztZQUVyQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsT0FBTyxDQUFDO2dCQUNyQixNQUFNLEVBQUUsSUFBSTtnQkFDWixTQUFTLEVBQUUsTUFBTSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUM7YUFDOUIsQ0FBQyxDQUFDO1FBQ0wsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy92YWRpbS9Qcm9qZWN0cy9WaXNBUEkvYXBwcy9iYWNrZW5kL3NyYy9oZWFsdGgvaGVhbHRoLmNvbnRyb2xsZXIuc3BlYy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUZXN0LCBUZXN0aW5nTW9kdWxlIH0gZnJvbSAnQG5lc3Rqcy90ZXN0aW5nJztcbmltcG9ydCB7IEhlYWx0aENvbnRyb2xsZXIgfSBmcm9tICcuL2hlYWx0aC5jb250cm9sbGVyJztcbmltcG9ydCB7XG4gIFRlcm1pbnVzTW9kdWxlLFxuICBIZWFsdGhDaGVja1NlcnZpY2UsXG59IGZyb20gJ0BuZXN0anMvdGVybWludXMnO1xuaW1wb3J0IHsgUmVkaXNIZWFsdGhJbmRpY2F0b3IgfSBmcm9tICcuL2luZGljYXRvcnMvcmVkaXMuaGVhbHRoJztcbmltcG9ydCB7IFN1cGFiYXNlSGVhbHRoSW5kaWNhdG9yIH0gZnJvbSAnLi9pbmRpY2F0b3JzL3N1cGFiYXNlLmhlYWx0aCc7XG5cbmRlc2NyaWJlKCdIZWFsdGhDb250cm9sbGVyJywgKCkgPT4ge1xuICBsZXQgY29udHJvbGxlcjogSGVhbHRoQ29udHJvbGxlcjtcbiAgbGV0IGhlYWx0aENoZWNrU2VydmljZTogamVzdC5Nb2NrZWQ8SGVhbHRoQ2hlY2tTZXJ2aWNlPjtcbiAgbGV0IHJlZGlzSGVhbHRoOiBqZXN0Lk1vY2tlZDxSZWRpc0hlYWx0aEluZGljYXRvcj47XG4gIGxldCBzdXBhYmFzZUhlYWx0aDogamVzdC5Nb2NrZWQ8U3VwYWJhc2VIZWFsdGhJbmRpY2F0b3I+O1xuXG4gIGNvbnN0IG1vY2tIZWFsdGhDaGVja1NlcnZpY2UgPSB7XG4gICAgY2hlY2s6IGplc3QuZm4oKSxcbiAgfTtcblxuICBiZWZvcmVFYWNoKGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBtb2R1bGU6IFRlc3RpbmdNb2R1bGUgPSBhd2FpdCBUZXN0LmNyZWF0ZVRlc3RpbmdNb2R1bGUoe1xuICAgICAgaW1wb3J0czogW1Rlcm1pbnVzTW9kdWxlXSxcbiAgICAgIGNvbnRyb2xsZXJzOiBbSGVhbHRoQ29udHJvbGxlcl0sXG4gICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAge1xuICAgICAgICAgIHByb3ZpZGU6IEhlYWx0aENoZWNrU2VydmljZSxcbiAgICAgICAgICB1c2VWYWx1ZTogbW9ja0hlYWx0aENoZWNrU2VydmljZSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHByb3ZpZGU6IFJlZGlzSGVhbHRoSW5kaWNhdG9yLFxuICAgICAgICAgIHVzZVZhbHVlOiB7XG4gICAgICAgICAgICBpc0hlYWx0aHk6IGplc3QuZm4oKSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgcHJvdmlkZTogU3VwYWJhc2VIZWFsdGhJbmRpY2F0b3IsXG4gICAgICAgICAgdXNlVmFsdWU6IHtcbiAgICAgICAgICAgIGlzSGVhbHRoeTogamVzdC5mbigpLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgIH0pLmNvbXBpbGUoKTtcblxuICAgIGNvbnRyb2xsZXIgPSBtb2R1bGUuZ2V0PEhlYWx0aENvbnRyb2xsZXI+KEhlYWx0aENvbnRyb2xsZXIpO1xuICAgIGhlYWx0aENoZWNrU2VydmljZSA9IG1vZHVsZS5nZXQoSGVhbHRoQ2hlY2tTZXJ2aWNlKSBhcyBqZXN0Lk1vY2tlZDxIZWFsdGhDaGVja1NlcnZpY2U+O1xuICAgIHJlZGlzSGVhbHRoID0gbW9kdWxlLmdldChSZWRpc0hlYWx0aEluZGljYXRvcik7XG4gICAgc3VwYWJhc2VIZWFsdGggPSBtb2R1bGUuZ2V0KFN1cGFiYXNlSGVhbHRoSW5kaWNhdG9yKTtcbiAgfSk7XG5cbiAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBiZSBkZWZpbmVkJywgKCkgPT4ge1xuICAgIGV4cGVjdChjb250cm9sbGVyKS50b0JlRGVmaW5lZCgpO1xuICB9KTtcblxuICBkZXNjcmliZSgnY2hlY2snLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gaGVhbHRoeSBzdGF0dXMgd2hlbiBhbGwgc2VydmljZXMgYXJlIHVwJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0hlYWx0aFJlc3VsdCA9IHtcbiAgICAgICAgc3RhdHVzOiAnb2snIGFzIGNvbnN0LFxuICAgICAgICBpbmZvOiB7XG4gICAgICAgICAgcmVkaXM6IHtcbiAgICAgICAgICAgIHN0YXR1czogJ3VwJyBhcyBjb25zdCxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRhdGFiYXNlOiB7XG4gICAgICAgICAgICBzdGF0dXM6ICd1cCcgYXMgY29uc3QsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IHt9LFxuICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgcmVkaXM6IHtcbiAgICAgICAgICAgIHN0YXR1czogJ3VwJyBhcyBjb25zdCxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRhdGFiYXNlOiB7XG4gICAgICAgICAgICBzdGF0dXM6ICd1cCcgYXMgY29uc3QsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH07XG5cbiAgICAgIG1vY2tIZWFsdGhDaGVja1NlcnZpY2UuY2hlY2subW9ja1Jlc29sdmVkVmFsdWUobW9ja0hlYWx0aFJlc3VsdCk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbnRyb2xsZXIuY2hlY2soKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChtb2NrSGVhbHRoUmVzdWx0KTtcbiAgICAgIGV4cGVjdChtb2NrSGVhbHRoQ2hlY2tTZXJ2aWNlLmNoZWNrKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChbXG4gICAgICAgIGV4cGVjdC5hbnkoRnVuY3Rpb24pLFxuICAgICAgICBleHBlY3QuYW55KEZ1bmN0aW9uKSxcbiAgICAgIF0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gZXJyb3Igc3RhdHVzIHdoZW4gc2VydmljZXMgYXJlIGRvd24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrSGVhbHRoUmVzdWx0ID0ge1xuICAgICAgICBzdGF0dXM6ICdlcnJvcicgYXMgY29uc3QsXG4gICAgICAgIGluZm86IHt9LFxuICAgICAgICBlcnJvcjoge1xuICAgICAgICAgIHJlZGlzOiB7XG4gICAgICAgICAgICBzdGF0dXM6ICdkb3duJyBhcyBjb25zdCxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdDb25uZWN0aW9uIHJlZnVzZWQnLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGF0YWJhc2U6IHtcbiAgICAgICAgICAgIHN0YXR1czogJ2Rvd24nIGFzIGNvbnN0LFxuICAgICAgICAgICAgbWVzc2FnZTogJ1RpbWVvdXQnLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICByZWRpczoge1xuICAgICAgICAgICAgc3RhdHVzOiAnZG93bicgYXMgY29uc3QsXG4gICAgICAgICAgICBtZXNzYWdlOiAnQ29ubmVjdGlvbiByZWZ1c2VkJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRhdGFiYXNlOiB7XG4gICAgICAgICAgICBzdGF0dXM6ICdkb3duJyBhcyBjb25zdCxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdUaW1lb3V0JyxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfTtcblxuICAgICAgbW9ja0hlYWx0aENoZWNrU2VydmljZS5jaGVjay5tb2NrUmVqZWN0ZWRWYWx1ZSh7XG4gICAgICAgIHJlc3BvbnNlOiBtb2NrSGVhbHRoUmVzdWx0LFxuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChjb250cm9sbGVyLmNoZWNrKCkpLnJlamVjdHMudG9NYXRjaE9iamVjdCh7XG4gICAgICAgIHJlc3BvbnNlOiBtb2NrSGVhbHRoUmVzdWx0LFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdsaXZlbmVzcycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHJldHVybiBvayBzdGF0dXMgZm9yIGxpdmVuZXNzIHByb2JlJywgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gY29udHJvbGxlci5saXZlbmVzcygpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKHtcbiAgICAgICAgc3RhdHVzOiAnb2snLFxuICAgICAgICB0aW1lc3RhbXA6IGV4cGVjdC5hbnkoU3RyaW5nKSxcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuIl0sInZlcnNpb24iOjN9