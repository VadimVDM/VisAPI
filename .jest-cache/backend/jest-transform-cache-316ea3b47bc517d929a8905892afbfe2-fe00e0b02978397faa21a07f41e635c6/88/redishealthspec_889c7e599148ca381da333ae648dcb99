609e3160d6def15a231d5b5ad980dee2
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const testing_1 = require("@nestjs/testing");
const terminus_1 = require("@nestjs/terminus");
const redis_health_1 = require("./redis.health");
const util_redis_1 = require("@visapi/util-redis");
describe('RedisHealthIndicator', () => {
    let indicator;
    let redisService;
    beforeEach(() => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        jest.clearAllMocks();
        const mockRedisService = {
            checkConnection: jest.fn(),
        };
        const module = yield testing_1.Test.createTestingModule({
            providers: [
                redis_health_1.RedisHealthIndicator,
                {
                    provide: util_redis_1.RedisService,
                    useValue: mockRedisService,
                },
            ],
        }).compile();
        indicator = module.get(redis_health_1.RedisHealthIndicator);
        redisService = module.get(util_redis_1.RedisService);
    }));
    it('should be defined', () => {
        expect(indicator).toBeDefined();
    });
    describe('isHealthy', () => {
        const healthKey = 'redis';
        it('should return healthy status when Redis connection is successful', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            redisService.checkConnection.mockResolvedValue(true);
            const result = yield indicator.isHealthy(healthKey);
            expect(result).toEqual({
                redis: {
                    status: 'up',
                    message: 'Redis is accessible and responsive',
                },
            });
            expect(redisService.checkConnection).toHaveBeenCalledTimes(1);
        }));
        it('should throw HealthCheckError when Redis connection fails', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            redisService.checkConnection.mockResolvedValue(false);
            yield expect(indicator.isHealthy(healthKey)).rejects.toThrow(terminus_1.HealthCheckError);
            expect(redisService.checkConnection).toHaveBeenCalledTimes(1);
        }));
        it('should throw HealthCheckError when Redis service throws an error', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const error = new Error('Connection timeout');
            redisService.checkConnection.mockRejectedValue(error);
            yield expect(indicator.isHealthy(healthKey)).rejects.toThrow(terminus_1.HealthCheckError);
            try {
                yield indicator.isHealthy(healthKey);
            }
            catch (err) {
                expect(err).toBeInstanceOf(terminus_1.HealthCheckError);
                expect(err.message).toBe('Redis connection failed');
                expect(err.causes).toEqual({
                    redis: {
                        status: 'down',
                        message: 'Unable to connect to Redis',
                        error: 'Connection timeout',
                    },
                });
            }
        }));
        it('should include the provided key in the health status', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const customKey = 'redis_cluster';
            redisService.checkConnection.mockResolvedValue(true);
            const result = yield indicator.isHealthy(customKey);
            expect(result).toHaveProperty(customKey);
            expect(result[customKey]).toEqual({
                status: 'up',
                message: 'Redis is accessible and responsive',
            });
        }));
        it('should handle Redis service timeout gracefully', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            redisService.checkConnection.mockResolvedValue(false);
            yield expect(indicator.isHealthy(healthKey)).rejects.toThrow(terminus_1.HealthCheckError);
            try {
                yield indicator.isHealthy(healthKey);
            }
            catch (err) {
                expect(err).toBeInstanceOf(terminus_1.HealthCheckError);
                expect(err.message).toBe('Redis connection failed');
                expect(err.causes).toEqual({
                    redis: {
                        status: 'down',
                        message: 'Unable to connect to Redis',
                        error: 'Redis connection failed',
                    },
                });
            }
        }));
        it('should handle Redis service connection error', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const error = new Error('Redis connection failed');
            redisService.checkConnection.mockRejectedValue(error);
            yield expect(indicator.isHealthy(healthKey)).rejects.toThrow(terminus_1.HealthCheckError);
            try {
                yield indicator.isHealthy(healthKey);
            }
            catch (err) {
                expect(err).toBeInstanceOf(terminus_1.HealthCheckError);
                expect(err.message).toBe('Redis connection failed');
                expect(err.causes).toEqual({
                    redis: {
                        status: 'down',
                        message: 'Unable to connect to Redis',
                        error: 'Redis connection failed',
                    },
                });
            }
        }));
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL3ZhZGltL1Byb2plY3RzL1Zpc0FQSS9hcHBzL2JhY2tlbmQvc3JjL2hlYWx0aC9pbmRpY2F0b3JzL3JlZGlzLmhlYWx0aC5zcGVjLnRzIiwibWFwcGluZ3MiOiI7OztBQUFBLDZDQUFzRDtBQUN0RCwrQ0FBb0Q7QUFDcEQsaURBQXNEO0FBQ3RELG1EQUFrRDtBQUVsRCxRQUFRLENBQUMsc0JBQXNCLEVBQUUsR0FBRyxFQUFFO0lBQ3BDLElBQUksU0FBK0IsQ0FBQztJQUNwQyxJQUFJLFlBQXVDLENBQUM7SUFFNUMsVUFBVSxDQUFDLEdBQVMsRUFBRTtRQUNwQixJQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7UUFFckIsTUFBTSxnQkFBZ0IsR0FBRztZQUN2QixlQUFlLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRTtTQUMzQixDQUFDO1FBRUYsTUFBTSxNQUFNLEdBQWtCLE1BQU0sY0FBSSxDQUFDLG1CQUFtQixDQUFDO1lBQzNELFNBQVMsRUFBRTtnQkFDVCxtQ0FBb0I7Z0JBQ3BCO29CQUNFLE9BQU8sRUFBRSx5QkFBWTtvQkFDckIsUUFBUSxFQUFFLGdCQUFnQjtpQkFDM0I7YUFDRjtTQUNGLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUViLFNBQVMsR0FBRyxNQUFNLENBQUMsR0FBRyxDQUF1QixtQ0FBb0IsQ0FBQyxDQUFDO1FBQ25FLFlBQVksR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDLHlCQUFZLENBQThCLENBQUM7SUFDdkUsQ0FBQyxDQUFBLENBQUMsQ0FBQztJQUVILEVBQUUsQ0FBQyxtQkFBbUIsRUFBRSxHQUFHLEVBQUU7UUFDM0IsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDO0lBQ2xDLENBQUMsQ0FBQyxDQUFDO0lBRUgsUUFBUSxDQUFDLFdBQVcsRUFBRSxHQUFHLEVBQUU7UUFDekIsTUFBTSxTQUFTLEdBQUcsT0FBTyxDQUFDO1FBRTFCLEVBQUUsQ0FBQyxrRUFBa0UsRUFBRSxHQUFTLEVBQUU7WUFDaEYsWUFBWSxDQUFDLGVB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QXlCLENBQUMsQ0FBQztnQkFDcEQsTUFBTSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxPQUFPLENBQUM7b0JBQ3pCLEtBQUssRUFBRTt3QkFDTCxNQUFNLEVBQUUsTUFBTTt3QkFDZCxPQUFPLEVBQUUsNEJBQTRCO3dCQUNyQyxLQUFLLEVBQUUseUJBQXlCO3FCQUNqQztpQkFDRixDQUFDLENBQUM7WUFDTCxDQUFDO1FBQ0gsQ0FBQyxDQUFBLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL1VzZXJzL3ZhZGltL1Byb2plY3RzL1Zpc0FQSS9hcHBzL2JhY2tlbmQvc3JjL2hlYWx0aC9pbmRpY2F0b3JzL3JlZGlzLmhlYWx0aC5zcGVjLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFRlc3QsIFRlc3RpbmdNb2R1bGUgfSBmcm9tICdAbmVzdGpzL3Rlc3RpbmcnO1xuaW1wb3J0IHsgSGVhbHRoQ2hlY2tFcnJvciB9IGZyb20gJ0BuZXN0anMvdGVybWludXMnO1xuaW1wb3J0IHsgUmVkaXNIZWFsdGhJbmRpY2F0b3IgfSBmcm9tICcuL3JlZGlzLmhlYWx0aCc7XG5pbXBvcnQgeyBSZWRpc1NlcnZpY2UgfSBmcm9tICdAdmlzYXBpL3V0aWwtcmVkaXMnO1xuXG5kZXNjcmliZSgnUmVkaXNIZWFsdGhJbmRpY2F0b3InLCAoKSA9PiB7XG4gIGxldCBpbmRpY2F0b3I6IFJlZGlzSGVhbHRoSW5kaWNhdG9yO1xuICBsZXQgcmVkaXNTZXJ2aWNlOiBqZXN0Lk1vY2tlZDxSZWRpc1NlcnZpY2U+O1xuXG4gIGJlZm9yZUVhY2goYXN5bmMgKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuXG4gICAgY29uc3QgbW9ja1JlZGlzU2VydmljZSA9IHtcbiAgICAgIGNoZWNrQ29ubmVjdGlvbjogamVzdC5mbigpLFxuICAgIH07XG5cbiAgICBjb25zdCBtb2R1bGU6IFRlc3RpbmdNb2R1bGUgPSBhd2FpdCBUZXN0LmNyZWF0ZVRlc3RpbmdNb2R1bGUoe1xuICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIFJlZGlzSGVhbHRoSW5kaWNhdG9yLFxuICAgICAgICB7XG4gICAgICAgICAgcHJvdmlkZTogUmVkaXNTZXJ2aWNlLFxuICAgICAgICAgIHVzZVZhbHVlOiBtb2NrUmVkaXNTZXJ2aWNlLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICB9KS5jb21waWxlKCk7XG5cbiAgICBpbmRpY2F0b3IgPSBtb2R1bGUuZ2V0PFJlZGlzSGVhbHRoSW5kaWNhdG9yPihSZWRpc0hlYWx0aEluZGljYXRvcik7XG4gICAgcmVkaXNTZXJ2aWNlID0gbW9kdWxlLmdldChSZWRpc1NlcnZpY2UpIGFzIGplc3QuTW9ja2VkPFJlZGlzU2VydmljZT47XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgYmUgZGVmaW5lZCcsICgpID0+IHtcbiAgICBleHBlY3QoaW5kaWNhdG9yKS50b0JlRGVmaW5lZCgpO1xuICB9KTtcblxuICBkZXNjcmliZSgnaXNIZWFsdGh5JywgKCkgPT4ge1xuICAgIGNvbnN0IGhlYWx0aEtleSA9ICdyZWRpcyc7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBoZWFsdGh5IHN0YXR1cyB3aGVuIFJlZGlzIGNvbm5lY3Rpb24gaXMgc3VjY2Vzc2Z1bCcsIGFzeW5jICgpID0+IHtcbiAgICAgIHJlZGlzU2VydmljZS5jaGVja0Nvbm5lY3Rpb24ubW9ja1Jlc29sdmVkVmFsdWUodHJ1ZSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGluZGljYXRvci5pc0hlYWx0aHkoaGVhbHRoS2V5KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbCh7XG4gICAgICAgIHJlZGlzOiB7XG4gICAgICAgICAgc3RhdHVzOiAndXAnLFxuICAgICAgICAgIG1lc3NhZ2U6ICdSZWRpcyBpcyBhY2Nlc3NpYmxlIGFuZCByZXNwb25zaXZlJyxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgICAgZXhwZWN0KHJlZGlzU2VydmljZS5jaGVja0Nvbm5lY3Rpb24pLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdGhyb3cgSGVhbHRoQ2hlY2tFcnJvciB3aGVuIFJlZGlzIGNvbm5lY3Rpb24gZmFpbHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICByZWRpc1NlcnZpY2UuY2hlY2tDb25uZWN0aW9uLm1vY2tSZXNvbHZlZFZhbHVlKGZhbHNlKTtcblxuICAgICAgYXdhaXQgZXhwZWN0KGluZGljYXRvci5pc0hlYWx0aHkoaGVhbHRoS2V5KSkucmVqZWN0cy50b1Rocm93KFxuICAgICAgICBIZWFsdGhDaGVja0Vycm9yXG4gICAgICApO1xuICAgICAgZXhwZWN0KHJlZGlzU2VydmljZS5jaGVja0Nvbm5lY3Rpb24pLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdGhyb3cgSGVhbHRoQ2hlY2tFcnJvciB3aGVuIFJlZGlzIHNlcnZpY2UgdGhyb3dzIGFuIGVycm9yJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24gdGltZW91dCcpO1xuICAgICAgcmVkaXNTZXJ2aWNlLmNoZWNrQ29ubmVjdGlvbi5tb2NrUmVqZWN0ZWRWYWx1ZShlcnJvcik7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChpbmRpY2F0b3IuaXNIZWFsdGh5KGhlYWx0aEtleSkpLnJlamVjdHMudG9UaHJvdyhcbiAgICAgICAgSGVhbHRoQ2hlY2tFcnJvclxuICAgICAgKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgaW5kaWNhdG9yLmlzSGVhbHRoeShoZWFsdGhLZXkpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGV4cGVjdChlcnIpLnRvQmVJbnN0YW5jZU9mKEhlYWx0aENoZWNrRXJyb3IpO1xuICAgICAgICBleHBlY3QoZXJyLm1lc3NhZ2UpLnRvQmUoJ1JlZGlzIGNvbm5lY3Rpb24gZmFpbGVkJyk7XG4gICAgICAgIGV4cGVjdChlcnIuY2F1c2VzKS50b0VxdWFsKHtcbiAgICAgICAgICByZWRpczoge1xuICAgICAgICAgICAgc3RhdHVzOiAnZG93bicsXG4gICAgICAgICAgICBtZXNzYWdlOiAnVW5hYmxlIHRvIGNvbm5lY3QgdG8gUmVkaXMnLFxuICAgICAgICAgICAgZXJyb3I6ICdDb25uZWN0aW9uIHRpbWVvdXQnLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBpbmNsdWRlIHRoZSBwcm92aWRlZCBrZXkgaW4gdGhlIGhlYWx0aCBzdGF0dXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjdXN0b21LZXkgPSAncmVkaXNfY2x1c3Rlcic7XG4gICAgICByZWRpc1NlcnZpY2UuY2hlY2tDb25uZWN0aW9uLm1vY2tSZXNvbHZlZFZhbHVlKHRydWUpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBpbmRpY2F0b3IuaXNIZWFsdGh5KGN1c3RvbUtleSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvSGF2ZVByb3BlcnR5KGN1c3RvbUtleSk7XG4gICAgICBleHBlY3QocmVzdWx0W2N1c3RvbUtleV0pLnRvRXF1YWwoe1xuICAgICAgICBzdGF0dXM6ICd1cCcsXG4gICAgICAgIG1lc3NhZ2U6ICdSZWRpcyBpcyBhY2Nlc3NpYmxlIGFuZCByZXNwb25zaXZlJyxcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgUmVkaXMgc2VydmljZSB0aW1lb3V0IGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICByZWRpc1NlcnZpY2UuY2hlY2tDb25uZWN0aW9uLm1vY2tSZXNvbHZlZFZhbHVlKGZhbHNlKTtcblxuICAgICAgYXdhaXQgZXhwZWN0KGluZGljYXRvci5pc0hlYWx0aHkoaGVhbHRoS2V5KSkucmVqZWN0cy50b1Rocm93KFxuICAgICAgICBIZWFsdGhDaGVja0Vycm9yXG4gICAgICApO1xuXG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBpbmRpY2F0b3IuaXNIZWFsdGh5KGhlYWx0aEtleSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgZXhwZWN0KGVycikudG9CZUluc3RhbmNlT2YoSGVhbHRoQ2hlY2tFcnJvcik7XG4gICAgICAgIGV4cGVjdChlcnIubWVzc2FnZSkudG9CZSgnUmVkaXMgY29ubmVjdGlvbiBmYWlsZWQnKTtcbiAgICAgICAgZXhwZWN0KGVyci5jYXVzZXMpLnRvRXF1YWwoe1xuICAgICAgICAgIHJlZGlzOiB7XG4gICAgICAgICAgICBzdGF0dXM6ICdkb3duJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdVbmFibGUgdG8gY29ubmVjdCB0byBSZWRpcycsXG4gICAgICAgICAgICBlcnJvcjogJ1JlZGlzIGNvbm5lY3Rpb24gZmFpbGVkJyxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIFJlZGlzIHNlcnZpY2UgY29ubmVjdGlvbiBlcnJvcicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdSZWRpcyBjb25uZWN0aW9uIGZhaWxlZCcpO1xuICAgICAgcmVkaXNTZXJ2aWNlLmNoZWNrQ29ubmVjdGlvbi5tb2NrUmVqZWN0ZWRWYWx1ZShlcnJvcik7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChpbmRpY2F0b3IuaXNIZWFsdGh5KGhlYWx0aEtleSkpLnJlamVjdHMudG9UaHJvdyhcbiAgICAgICAgSGVhbHRoQ2hlY2tFcnJvclxuICAgICAgKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgaW5kaWNhdG9yLmlzSGVhbHRoeShoZWFsdGhLZXkpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGV4cGVjdChlcnIpLnRvQmVJbnN0YW5jZU9mKEhlYWx0aENoZWNrRXJyb3IpO1xuICAgICAgICBleHBlY3QoZXJyLm1lc3NhZ2UpLnRvQmUoJ1JlZGlzIGNvbm5lY3Rpb24gZmFpbGVkJyk7XG4gICAgICAgIGV4cGVjdChlcnIuY2F1c2VzKS50b0VxdWFsKHtcbiAgICAgICAgICByZWRpczoge1xuICAgICAgICAgICAgc3RhdHVzOiAnZG93bicsXG4gICAgICAgICAgICBtZXNzYWdlOiAnVW5hYmxlIHRvIGNvbm5lY3QgdG8gUmVkaXMnLFxuICAgICAgICAgICAgZXJyb3I6ICdSZWRpcyBjb25uZWN0aW9uIGZhaWxlZCcsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufSk7Il0sInZlcnNpb24iOjN9