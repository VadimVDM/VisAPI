62182481c3b166f6724b375991fbdb21
"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.SupabaseService = void 0;
const tslib_1 = require("tslib");
const common_1 = require("@nestjs/common");
const supabase_js_1 = require("@supabase/supabase-js");
const core_config_1 = require("@visapi/core-config");
let SupabaseService = class SupabaseService {
    constructor(config) {
        this.config = config;
    }
    onModuleInit() {
        // Client for public operations (using anon key)
        this.supabase = (0, supabase_js_1.createClient)(this.config.supabaseUrl, this.config.supabaseAnonKey);
        // Client for service operations (using service role key)
        this.serviceSupabase = (0, supabase_js_1.createClient)(this.config.supabaseUrl, this.config.supabaseServiceRoleKey, {
            auth: {
                autoRefreshToken: false,
                persistSession: false,
            },
        });
    }
    get client() {
        return this.supabase;
    }
    get serviceClient() {
        return this.serviceSupabase;
    }
    checkConnection() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const { error } = yield this.serviceSupabase
                    .from('users')
                    .select('count')
                    .limit(1);
                return !error;
            }
            catch (_a) {
                return false;
            }
        });
    }
};
exports.SupabaseService = SupabaseService;
exports.SupabaseService = SupabaseService = tslib_1.__decorate([
    (0, common_1.Injectable)(),
    tslib_1.__metadata("design:paramtypes", [typeof (_a = typeof core_config_1.ConfigService !== "undefined" && core_config_1.ConfigService) === "function" ? _a : Object])
], SupabaseService);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL3ZhZGltL1Byb2plY3RzL1Zpc0FQSS9saWJzL2JhY2tlbmQvY29yZS1zdXBhYmFzZS9zcmMvbGliL3N1cGFiYXNlLnNlcnZpY2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSwyQ0FBMEQ7QUFDMUQsdURBQXFFO0FBQ3JFLHFEQUFvRDtBQUk3QyxJQUFNLGVBQWUsR0FBckIsTUFBTSxlQUFlO0lBSTFCLFlBQTZCLE1BQXFCO1FBQXJCLFdBQU0sR0FBTixNQUFNLENBQWU7SUFBRyxDQUFDO0lBRXRELFlBQVk7UUFDVixnREFBZ0Q7UUFDaEQsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFBLDBCQUFZLEVBQzFCLElBQUksQ0FBQyxNQUFNLENBQUMsV0FBVyxFQUN2QixJQUFJLENBQUMsTUFBTSxDQUFDLGVBQWUsQ0FDNUIsQ0FBQztRQUVGLHlEQUF5RDtRQUN6RCxJQUFJLENBQUMsZUFBZSxHQUFHLElBQUEsMEJBQVksRUFDakMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxXQUFXLEVBQ3ZCLElBQUksQ0FBQyxNQUFNLENBQUMsc0JBQXNCLEVBQ2xDO1lBQ0UsSUFBSSxFQUFFO2dCQUNKLGdCQUFnQixFQUFFLEtBQUs7Z0JBQ3ZCLGNBQWMsRUFBRSxLQUFLO2FBQ3RCO1NBQ0YsQ0FDRixDQUFDO0lBQ0osQ0FBQztJQUVELElBQUksTUFBTTtRQUNSLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQztJQUN2QixDQUFDO0lBRUQsSUFBSSxhQUFhO1FBQ2YsT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDO0lBQzlCLENBQUM7SUFFSyxlQUFlOztZQUNuQixJQUFJLENBQUM7Z0JBQ0gsTUFBTSxFQUFFLEtBQUssRUFBRSxHQUFHLE1BQU0sSUFBSSxDQUFDLGVBQWU7cUJBQ3pDLElBQUksQ0FBQyxPQUFPLENBQUM7cUJBQ2IsTUFBTSxDQUFDLE9BQU8sQ0FBQztxQkFDZixLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ1osT0FBTyxDQUFDLEtBQUssQ0FBQztZQUNoQixDQUFDO1lBQUMsV0FBTSxDQUFDO2dCQUNQLE9BQU8sS0FBSyxDQUFDO1lBQ2YsQ0FBQztRQUNILENBQUM7S0FBQTtDQUNGLENBQUE7QUE3Q1ksMENBQWU7MEJBQWYsZUFBZTtJQUQzQixJQUFBLG1CQUFVLEdBQUU7aUVBSzBCLDJCQUFhLG9CQUFiLDJCQUFhO0dBSnZDLGVBQWUsQ0E2QzNCIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy92YWRpbS9Qcm9qZWN0cy9WaXNBUEkvbGlicy9iYWNrZW5kL2NvcmUtc3VwYWJhc2Uvc3JjL2xpYi9zdXBhYmFzZS5zZXJ2aWNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIE9uTW9kdWxlSW5pdCB9IGZyb20gJ0BuZXN0anMvY29tbW9uJztcbmltcG9ydCB7IGNyZWF0ZUNsaWVudCwgU3VwYWJhc2VDbGllbnQgfSBmcm9tICdAc3VwYWJhc2Uvc3VwYWJhc2UtanMnO1xuaW1wb3J0IHsgQ29uZmlnU2VydmljZSB9IGZyb20gJ0B2aXNhcGkvY29yZS1jb25maWcnO1xuaW1wb3J0IHsgRGF0YWJhc2UgfSBmcm9tICdAdmlzYXBpL3NoYXJlZC10eXBlcyc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBTdXBhYmFzZVNlcnZpY2UgaW1wbGVtZW50cyBPbk1vZHVsZUluaXQge1xuICBwcml2YXRlIHN1cGFiYXNlOiBTdXBhYmFzZUNsaWVudDxEYXRhYmFzZT47XG4gIHByaXZhdGUgc2VydmljZVN1cGFiYXNlOiBTdXBhYmFzZUNsaWVudDxEYXRhYmFzZT47XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBjb25maWc6IENvbmZpZ1NlcnZpY2UpIHt9XG5cbiAgb25Nb2R1bGVJbml0KCkge1xuICAgIC8vIENsaWVudCBmb3IgcHVibGljIG9wZXJhdGlvbnMgKHVzaW5nIGFub24ga2V5KVxuICAgIHRoaXMuc3VwYWJhc2UgPSBjcmVhdGVDbGllbnQ8RGF0YWJhc2U+KFxuICAgICAgdGhpcy5jb25maWcuc3VwYWJhc2VVcmwsXG4gICAgICB0aGlzLmNvbmZpZy5zdXBhYmFzZUFub25LZXlcbiAgICApO1xuXG4gICAgLy8gQ2xpZW50IGZvciBzZXJ2aWNlIG9wZXJhdGlvbnMgKHVzaW5nIHNlcnZpY2Ugcm9sZSBrZXkpXG4gICAgdGhpcy5zZXJ2aWNlU3VwYWJhc2UgPSBjcmVhdGVDbGllbnQ8RGF0YWJhc2U+KFxuICAgICAgdGhpcy5jb25maWcuc3VwYWJhc2VVcmwsXG4gICAgICB0aGlzLmNvbmZpZy5zdXBhYmFzZVNlcnZpY2VSb2xlS2V5LFxuICAgICAge1xuICAgICAgICBhdXRoOiB7XG4gICAgICAgICAgYXV0b1JlZnJlc2hUb2tlbjogZmFsc2UsXG4gICAgICAgICAgcGVyc2lzdFNlc3Npb246IGZhbHNlLFxuICAgICAgICB9LFxuICAgICAgfVxuICAgICk7XG4gIH1cblxuICBnZXQgY2xpZW50KCk6IFN1cGFiYXNlQ2xpZW50PERhdGFiYXNlPiB7XG4gICAgcmV0dXJuIHRoaXMuc3VwYWJhc2U7XG4gIH1cblxuICBnZXQgc2VydmljZUNsaWVudCgpOiBTdXBhYmFzZUNsaWVudDxEYXRhYmFzZT4ge1xuICAgIHJldHVybiB0aGlzLnNlcnZpY2VTdXBhYmFzZTtcbiAgfVxuXG4gIGFzeW5jIGNoZWNrQ29ubmVjdGlvbigpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgdGhpcy5zZXJ2aWNlU3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3VzZXJzJylcbiAgICAgICAgLnNlbGVjdCgnY291bnQnKVxuICAgICAgICAubGltaXQoMSk7XG4gICAgICByZXR1cm4gIWVycm9yO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufVxuIl0sInZlcnNpb24iOjN9