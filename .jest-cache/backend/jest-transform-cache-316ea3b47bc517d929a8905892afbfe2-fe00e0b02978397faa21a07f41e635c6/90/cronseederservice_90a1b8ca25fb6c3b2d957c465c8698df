d5771421ceb52e6b4ad7bd0d52109e1f
"use strict";
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", { value: true });
exports.CronSeederService = void 0;
const tslib_1 = require("tslib");
const common_1 = require("@nestjs/common");
const nestjs_pino_1 = require("nestjs-pino");
const core_supabase_1 = require("@visapi/core-supabase");
const queue_service_1 = require("../queue/queue.service");
const shared_types_1 = require("@visapi/shared-types");
let CronSeederService = class CronSeederService {
    constructor(logger, supabase, queueService) {
        this.logger = logger;
        this.supabase = supabase;
        this.queueService = queueService;
    }
    onModuleInit() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.seedCronJobs();
        });
    }
    seedCronJobs() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.logger.info('Starting cron job seeding');
            try {
                // Get all enabled workflows with cron triggers
                const workflows = yield this.getWorkflowsWithCronTriggers();
                if (workflows.length === 0) {
                    this.logger.info('No workflows with cron triggers found');
                }
                else {
                    this.logger.info({ count: workflows.length }, 'Found workflows with cron triggers');
                }
                // Clear existing repeatable jobs first to ensure clean state
                yield this.clearExistingCronJobs();
                // Schedule log pruning job (daily at 2 AM)
                yield this.scheduleLogPruning();
                // Schedule each workflow
                for (const workflow of workflows) {
                    yield this.scheduleWorkflow(workflow);
                }
                this.logger.info('Cron job seeding completed successfully');
            }
            catch (error) {
                this.logger.error({ error }, 'Failed to seed cron jobs');
                throw error;
            }
        });
    }
    getWorkflowsWithCronTriggers() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { data, error } = yield this.supabase.client
                .from('workflows')
                .select('*')
                .eq('enabled', true);
            if (error) {
                throw new Error(`Failed to fetch workflows: ${error.message}`);
            }
            // Filter workflows that have cron triggers
            return (data || []).filter((workflow) => {
                var _a;
                const schema = workflow.schema;
                return (_a = schema === null || schema === void 0 ? void 0 : schema.triggers) === null || _a === void 0 ? void 0 : _a.some((trigger) => {
                    var _a;
                    return trigger.type === 'cron' &&
                        ((_a = trigger.config) === null || _a === void 0 ? void 0 : _a.schedule);
                });
            });
        });
    }
    clearExistingCronJobs() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            var _a;
            try {
                const repeatableJobs = yield this.queueService.getRepeatableJobs(shared_types_1.QUEUE_NAMES.DEFAULT);
                // Remove jobs that match our cron pattern
                for (const job of repeatableJobs) {
                    if (((_a = job.id) === null || _a === void 0 ? void 0 : _a.startsWith('cron-')) || job.id === 'log-pruning') {
                        const jobId = job.id.startsWith('cron-') ? job.id.replace('cron-', '') : job.id;
                        yield this.queueService.removeRepeatableJob(shared_types_1.QUEUE_NAMES.DEFAULT, jobId);
                    }
                }
            }
            catch (error) {
                this.logger.warn({ error }, 'Failed to clear existing cron jobs, continuing anyway');
            }
        });
    }
    scheduleWorkflow(workflow) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const schema = workflow.schema;
            const cronTriggers = schema.triggers.filter((trigger) => { var _a; return trigger.type === 'cron' && ((_a = trigger.config) === null || _a === void 0 ? void 0 : _a.schedule); });
            for (const trigger of cronTriggers) {
                try {
                    const schedule = trigger.config.schedule;
                    const timezone = trigger.config.timezone || 'UTC';
                    yield this.queueService.addRepeatableJob(shared_types_1.QUEUE_NAMES.DEFAULT, shared_types_1.JOB_NAMES.PROCESS_WORKFLOW, {
                        workflowId: workflow.id,
                        trigger: {
                            type: 'cron',
                            schedule,
                        },
                        metadata: {
                            workflowName: workflow.name,
                            scheduledBy: 'cron-seeder',
                        },
                    }, {
                        pattern: schedule,
                        tz: timezone,
                    });
                    this.logger.info({
                        workflowId: workflow.id,
                        workflowName: workflow.name,
                        schedule,
                        timezone,
                    }, 'Scheduled cron job for workflow');
                }
                catch (error) {
                    this.logger.error({
                        error,
                        workflowId: workflow.id,
                        workflowName: workflow.name,
                    }, 'Failed to schedule cron job for workflow');
                }
            }
        });
    }
    /**
     * Update cron jobs when a workflow is updated
     */
    updateWorkflowCronJobs(workflowId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            var _a;
            try {
                // Remove existing cron job
                yield this.queueService.removeRepeatableJob(shared_types_1.QUEUE_NAMES.DEFAULT, workflowId);
                // Fetch the updated workflow
                const { data: workflow, error } = yield this.supabase.client
                    .from('workflows')
                    .select('*')
                    .eq('id', workflowId)
                    .single();
                if (error || !workflow) {
                    this.logger.warn({ workflowId, error }, 'Workflow not found for cron update');
                    return;
                }
                // Reschedule if still enabled and has cron triggers
                if (workflow.enabled) {
                    const schema = workflow.schema;
                    const hasCronTrigger = (_a = schema === null || schema === void 0 ? void 0 : schema.triggers) === null || _a === void 0 ? void 0 : _a.some((trigger) => {
                        var _a;
                        return trigger.type === 'cron' &&
                            ((_a = trigger.config) === null || _a === void 0 ? void 0 : _a.schedule);
                    });
                    if (hasCronTrigger) {
                        yield this.scheduleWorkflow(workflow);
                    }
                }
            }
            catch (error) {
                this.logger.error({ error, workflowId }, 'Failed to update workflow cron jobs');
            }
        });
    }
    /**
     * Remove cron jobs when a workflow is deleted or disabled
     */
    removeWorkflowCronJobs(workflowId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                yield this.queueService.removeRepeatableJob(shared_types_1.QUEUE_NAMES.DEFAULT, workflowId);
                this.logger.info({ workflowId }, 'Removed cron jobs for workflow');
            }
            catch (error) {
                this.logger.error({ error, workflowId }, 'Failed to remove workflow cron jobs');
            }
        });
    }
    /**
     * Get cron drift metrics for monitoring
     */
    getCronDriftMetrics() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            var _a;
            const metrics = [];
            try {
                const repeatableJobs = yield this.queueService.getRepeatableJobs(shared_types_1.QUEUE_NAMES.DEFAULT);
                for (const job of repeatableJobs) {
                    if ((_a = job.id) === null || _a === void 0 ? void 0 : _a.startsWith('cron-')) {
                        const workflowId = job.id.replace('cron-', '');
                        const nextRun = new Date(job.next);
                        const now = new Date();
                        const drift = nextRun.getTime() - now.getTime();
                        metrics.push({
                            workflowId,
                            schedule: job.pattern,
                            nextRun,
                            drift: Math.abs(drift),
                        });
                    }
                }
            }
            catch (error) {
                this.logger.error({ error }, 'Failed to get cron drift metrics');
            }
            return metrics;
        });
    }
    /**
     * Schedule log pruning job to run daily at 2 AM UTC
     */
    scheduleLogPruning() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const schedule = '0 2 * * *'; // Daily at 2 AM UTC
                const olderThanDays = 90; // Default retention period
                yield this.queueService.addRepeatableJob(shared_types_1.QUEUE_NAMES.DEFAULT, shared_types_1.JOB_NAMES.PRUNE_LOGS, {
                    olderThanDays,
                }, {
                    pattern: schedule,
                    tz: 'UTC',
                });
                this.logger.info({
                    schedule,
                    olderThanDays,
                }, 'Scheduled log pruning job');
            }
            catch (error) {
                this.logger.error({ error }, 'Failed to schedule log pruning job');
            }
        });
    }
};
exports.CronSeederService = CronSeederService;
exports.CronSeederService = CronSeederService = tslib_1.__decorate([
    (0, common_1.Injectable)(),
    tslib_1.__param(0, (0, nestjs_pino_1.InjectPinoLogger)(CronSeederService.name)),
    tslib_1.__metadata("design:paramtypes", [typeof (_a = typeof nestjs_pino_1.PinoLogger !== "undefined" && nestjs_pino_1.PinoLogger) === "function" ? _a : Object, typeof (_b = typeof core_supabase_1.SupabaseService !== "undefined" && core_supabase_1.SupabaseService) === "function" ? _b : Object, typeof (_c = typeof queue_service_1.QueueService !== "undefined" && queue_service_1.QueueService) === "function" ? _c : Object])
], CronSeederService);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL3ZhZGltL1Byb2plY3RzL1Zpc0FQSS9hcHBzL2JhY2tlbmQvc3JjL2Nyb24vY3Jvbi1zZWVkZXIuc2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLDJDQUEwRDtBQUMxRCw2Q0FBMkQ7QUFDM0QseURBQXdEO0FBQ3hELDBEQUFzRDtBQUN0RCx1REFBOEU7QUFHdkUsSUFBTSxpQkFBaUIsR0FBdkIsTUFBTSxpQkFBaUI7SUFDNUIsWUFFbUIsTUFBa0IsRUFDbEIsUUFBeUIsRUFDekIsWUFBMEI7UUFGMUIsV0FBTSxHQUFOLE1BQU0sQ0FBWTtRQUNsQixhQUFRLEdBQVIsUUFBUSxDQUFpQjtRQUN6QixpQkFBWSxHQUFaLFlBQVksQ0FBYztJQUMxQyxDQUFDO0lBRUUsWUFBWTs7WUFDaEIsTUFBTSxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7UUFDNUIsQ0FBQztLQUFBO0lBRUssWUFBWTs7WUFDaEIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsMkJBQTJCLENBQUMsQ0FBQztZQUU5QyxJQUFJLENBQUM7Z0JBQ0gsK0NBQStDO2dCQUMvQyxNQUFNLFNBQVMsR0FBRyxNQUFNLElBQUksQ0FBQyw0QkFBNEIsRUFBRSxDQUFDO2dCQUU1RCxJQUFJLFNBQVMsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFLENBQUM7b0JBQzNCLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLHVDQUF1QyxDQUFDLENBQUM7Z0JBQzVELENBQUM7cUJBQU0sQ0FBQztvQkFDTixJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FDZCxFQUFFLEtBQUssRUFBRSxTQUFTLENBQUMsTUFBTSxFQUFFLEVBQzNCLG9DQUFvQyxDQUNyQyxDQUFDO2dCQUNKLENBQUM7Z0JBRUQsNkRBQTZEO2dCQUM3RCxNQUFNLElBQUksQ0FBQyxxQkFBcUIsRUFBRSxDQUFDO2dCQUVuQywyQ0FBMkM7Z0JBQzNDLE1BQU0sSUFBSSxDQUFDLGtCQUFrQixFQUFFLENBQUM7Z0JBRWhDLHlCQUF5QjtnQkFDekIs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QUUsRUFDVCxvQ0FBb0MsQ0FDckMsQ0FBQztZQUNKLENBQUM7UUFDSCxDQUFDO0tBQUE7Q0FDRixDQUFBO0FBL1JZLDhDQUFpQjs0QkFBakIsaUJBQWlCO0lBRDdCLElBQUEsbUJBQVUsR0FBRTtJQUdSLG1CQUFBLElBQUEsOEJBQWdCLEVBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLENBQUE7aUVBQ2hCLHdCQUFVLG9CQUFWLHdCQUFVLG9EQUNSLCtCQUFlLG9CQUFmLCtCQUFlLG9EQUNYLDRCQUFZLG9CQUFaLDRCQUFZO0dBTGxDLGlCQUFpQixDQStSN0IiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL1VzZXJzL3ZhZGltL1Byb2plY3RzL1Zpc0FQSS9hcHBzL2JhY2tlbmQvc3JjL2Nyb24vY3Jvbi1zZWVkZXIuc2VydmljZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBPbk1vZHVsZUluaXQgfSBmcm9tICdAbmVzdGpzL2NvbW1vbic7XG5pbXBvcnQgeyBJbmplY3RQaW5vTG9nZ2VyLCBQaW5vTG9nZ2VyIH0gZnJvbSAnbmVzdGpzLXBpbm8nO1xuaW1wb3J0IHsgU3VwYWJhc2VTZXJ2aWNlIH0gZnJvbSAnQHZpc2FwaS9jb3JlLXN1cGFiYXNlJztcbmltcG9ydCB7IFF1ZXVlU2VydmljZSB9IGZyb20gJy4uL3F1ZXVlL3F1ZXVlLnNlcnZpY2UnO1xuaW1wb3J0IHsgUVVFVUVfTkFNRVMsIEpPQl9OQU1FUywgV29ya2Zsb3dTY2hlbWEgfSBmcm9tICdAdmlzYXBpL3NoYXJlZC10eXBlcyc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBDcm9uU2VlZGVyU2VydmljZSBpbXBsZW1lbnRzIE9uTW9kdWxlSW5pdCB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIEBJbmplY3RQaW5vTG9nZ2VyKENyb25TZWVkZXJTZXJ2aWNlLm5hbWUpXG4gICAgcHJpdmF0ZSByZWFkb25seSBsb2dnZXI6IFBpbm9Mb2dnZXIsXG4gICAgcHJpdmF0ZSByZWFkb25seSBzdXBhYmFzZTogU3VwYWJhc2VTZXJ2aWNlLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgcXVldWVTZXJ2aWNlOiBRdWV1ZVNlcnZpY2UsXG4gICkge31cblxuICBhc3luYyBvbk1vZHVsZUluaXQoKSB7XG4gICAgYXdhaXQgdGhpcy5zZWVkQ3JvbkpvYnMoKTtcbiAgfVxuXG4gIGFzeW5jIHNlZWRDcm9uSm9icygpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0aGlzLmxvZ2dlci5pbmZvKCdTdGFydGluZyBjcm9uIGpvYiBzZWVkaW5nJyk7XG5cbiAgICB0cnkge1xuICAgICAgLy8gR2V0IGFsbCBlbmFibGVkIHdvcmtmbG93cyB3aXRoIGNyb24gdHJpZ2dlcnNcbiAgICAgIGNvbnN0IHdvcmtmbG93cyA9IGF3YWl0IHRoaXMuZ2V0V29ya2Zsb3dzV2l0aENyb25UcmlnZ2VycygpO1xuICAgICAgXG4gICAgICBpZiAod29ya2Zsb3dzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKCdObyB3b3JrZmxvd3Mgd2l0aCBjcm9uIHRyaWdnZXJzIGZvdW5kJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKFxuICAgICAgICAgIHsgY291bnQ6IHdvcmtmbG93cy5sZW5ndGggfSxcbiAgICAgICAgICAnRm91bmQgd29ya2Zsb3dzIHdpdGggY3JvbiB0cmlnZ2VycycsXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIENsZWFyIGV4aXN0aW5nIHJlcGVhdGFibGUgam9icyBmaXJzdCB0byBlbnN1cmUgY2xlYW4gc3RhdGVcbiAgICAgIGF3YWl0IHRoaXMuY2xlYXJFeGlzdGluZ0Nyb25Kb2JzKCk7XG5cbiAgICAgIC8vIFNjaGVkdWxlIGxvZyBwcnVuaW5nIGpvYiAoZGFpbHkgYXQgMiBBTSlcbiAgICAgIGF3YWl0IHRoaXMuc2NoZWR1bGVMb2dQcnVuaW5nKCk7XG5cbiAgICAgIC8vIFNjaGVkdWxlIGVhY2ggd29ya2Zsb3dcbiAgICAgIGZvciAoY29uc3Qgd29ya2Zsb3cgb2Ygd29ya2Zsb3dzKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc2NoZWR1bGVXb3JrZmxvdyh3b3JrZmxvdyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ0Nyb24gam9iIHNlZWRpbmcgY29tcGxldGVkIHN1Y2Nlc3NmdWxseScpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcih7IGVycm9yIH0sICdGYWlsZWQgdG8gc2VlZCBjcm9uIGpvYnMnKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZ2V0V29ya2Zsb3dzV2l0aENyb25UcmlnZ2VycygpOiBQcm9taXNlPGFueVtdPiB7XG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5zdXBhYmFzZS5jbGllbnRcbiAgICAgIC5mcm9tKCd3b3JrZmxvd3MnKVxuICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAuZXEoJ2VuYWJsZWQnLCB0cnVlKTtcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggd29ya2Zsb3dzOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuXG4gICAgLy8gRmlsdGVyIHdvcmtmbG93cyB0aGF0IGhhdmUgY3JvbiB0cmlnZ2Vyc1xuICAgIHJldHVybiAoZGF0YSB8fCBbXSkuZmlsdGVyKCh3b3JrZmxvdykgPT4ge1xuICAgICAgY29uc3Qgc2NoZW1hID0gd29ya2Zsb3cuc2NoZW1hIGFzIGFueTtcbiAgICAgIHJldHVybiBzY2hlbWE/LnRyaWdnZXJzPy5zb21lKFxuICAgICAgICAodHJpZ2dlcjogYW55KSA9PiBcbiAgICAgICAgICB0cmlnZ2VyLnR5cGUgPT09ICdjcm9uJyAmJiBcbiAgICAgICAgICB0cmlnZ2VyLmNvbmZpZz8uc2NoZWR1bGVcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGNsZWFyRXhpc3RpbmdDcm9uSm9icygpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVwZWF0YWJsZUpvYnMgPSBhd2FpdCB0aGlzLnF1ZXVlU2VydmljZS5nZXRSZXBlYXRhYmxlSm9icyhcbiAgICAgICAgUVVFVUVfTkFNRVMuREVGQVVMVCxcbiAgICAgICk7XG5cbiAgICAgIC8vIFJlbW92ZSBqb2JzIHRoYXQgbWF0Y2ggb3VyIGNyb24gcGF0dGVyblxuICAgICAgZm9yIChjb25zdCBqb2Igb2YgcmVwZWF0YWJsZUpvYnMpIHtcbiAgICAgICAgaWYgKGpvYi5pZD8uc3RhcnRzV2l0aCgnY3Jvbi0nKSB8fCBqb2IuaWQgPT09ICdsb2ctcHJ1bmluZycpIHtcbiAgICAgICAgICBjb25zdCBqb2JJZCA9IGpvYi5pZC5zdGFydHNXaXRoKCdjcm9uLScpID8gam9iLmlkLnJlcGxhY2UoJ2Nyb24tJywgJycpIDogam9iLmlkO1xuICAgICAgICAgIGF3YWl0IHRoaXMucXVldWVTZXJ2aWNlLnJlbW92ZVJlcGVhdGFibGVKb2IoXG4gICAgICAgICAgICBRVUVVRV9OQU1FUy5ERUZBVUxULFxuICAgICAgICAgICAgam9iSWQsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKFxuICAgICAgICB7IGVycm9yIH0sXG4gICAgICAgICdGYWlsZWQgdG8gY2xlYXIgZXhpc3RpbmcgY3JvbiBqb2JzLCBjb250aW51aW5nIGFueXdheScsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgc2NoZWR1bGVXb3JrZmxvdyh3b3JrZmxvdzogYW55KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3Qgc2NoZW1hID0gd29ya2Zsb3cuc2NoZW1hIGFzIGFueTtcbiAgICBjb25zdCBjcm9uVHJpZ2dlcnMgPSBzY2hlbWEudHJpZ2dlcnMuZmlsdGVyKFxuICAgICAgKHRyaWdnZXI6IGFueSkgPT4gdHJpZ2dlci50eXBlID09PSAnY3JvbicgJiYgdHJpZ2dlci5jb25maWc/LnNjaGVkdWxlLFxuICAgICk7XG5cbiAgICBmb3IgKGNvbnN0IHRyaWdnZXIgb2YgY3JvblRyaWdnZXJzKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBzY2hlZHVsZSA9IHRyaWdnZXIuY29uZmlnLnNjaGVkdWxlO1xuICAgICAgICBjb25zdCB0aW1lem9uZSA9IHRyaWdnZXIuY29uZmlnLnRpbWV6b25lIHx8ICdVVEMnO1xuXG4gICAgICAgIGF3YWl0IHRoaXMucXVldWVTZXJ2aWNlLmFkZFJlcGVhdGFibGVKb2IoXG4gICAgICAgICAgUVVFVUVfTkFNRVMuREVGQVVMVCxcbiAgICAgICAgICBKT0JfTkFNRVMuUFJPQ0VTU19XT1JLRkxPVyxcbiAgICAgICAgICB7XG4gICAgICAgICAgICB3b3JrZmxvd0lkOiB3b3JrZmxvdy5pZCxcbiAgICAgICAgICAgIHRyaWdnZXI6IHtcbiAgICAgICAgICAgICAgdHlwZTogJ2Nyb24nLFxuICAgICAgICAgICAgICBzY2hlZHVsZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgICB3b3JrZmxvd05hbWU6IHdvcmtmbG93Lm5hbWUsXG4gICAgICAgICAgICAgIHNjaGVkdWxlZEJ5OiAnY3Jvbi1zZWVkZXInLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHBhdHRlcm46IHNjaGVkdWxlLFxuICAgICAgICAgICAgdHo6IHRpbWV6b25lLFxuICAgICAgICAgIH0sXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhcbiAgICAgICAgICB7XG4gICAgICAgICAgICB3b3JrZmxvd0lkOiB3b3JrZmxvdy5pZCxcbiAgICAgICAgICAgIHdvcmtmbG93TmFtZTogd29ya2Zsb3cubmFtZSxcbiAgICAgICAgICAgIHNjaGVkdWxlLFxuICAgICAgICAgICAgdGltZXpvbmUsXG4gICAgICAgICAgfSxcbiAgICAgICAgICAnU2NoZWR1bGVkIGNyb24gam9iIGZvciB3b3JrZmxvdycsXG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcbiAgICAgICAgICB7XG4gICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgIHdvcmtmbG93SWQ6IHdvcmtmbG93LmlkLFxuICAgICAgICAgICAgd29ya2Zsb3dOYW1lOiB3b3JrZmxvdy5uYW1lLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgJ0ZhaWxlZCB0byBzY2hlZHVsZSBjcm9uIGpvYiBmb3Igd29ya2Zsb3cnLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgY3JvbiBqb2JzIHdoZW4gYSB3b3JrZmxvdyBpcyB1cGRhdGVkXG4gICAqL1xuICBhc3luYyB1cGRhdGVXb3JrZmxvd0Nyb25Kb2JzKHdvcmtmbG93SWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBSZW1vdmUgZXhpc3RpbmcgY3JvbiBqb2JcbiAgICAgIGF3YWl0IHRoaXMucXVldWVTZXJ2aWNlLnJlbW92ZVJlcGVhdGFibGVKb2IoXG4gICAgICAgIFFVRVVFX05BTUVTLkRFRkFVTFQsXG4gICAgICAgIHdvcmtmbG93SWQsXG4gICAgICApO1xuXG4gICAgICAvLyBGZXRjaCB0aGUgdXBkYXRlZCB3b3JrZmxvd1xuICAgICAgY29uc3QgeyBkYXRhOiB3b3JrZmxvdywgZXJyb3IgfSA9IGF3YWl0IHRoaXMuc3VwYWJhc2UuY2xpZW50XG4gICAgICAgIC5mcm9tKCd3b3JrZmxvd3MnKVxuICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgLmVxKCdpZCcsIHdvcmtmbG93SWQpXG4gICAgICAgIC5zaW5nbGUoKTtcblxuICAgICAgaWYgKGVycm9yIHx8ICF3b3JrZmxvdykge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFxuICAgICAgICAgIHsgd29ya2Zsb3dJZCwgZXJyb3IgfSxcbiAgICAgICAgICAnV29ya2Zsb3cgbm90IGZvdW5kIGZvciBjcm9uIHVwZGF0ZScsXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gUmVzY2hlZHVsZSBpZiBzdGlsbCBlbmFibGVkIGFuZCBoYXMgY3JvbiB0cmlnZ2Vyc1xuICAgICAgaWYgKHdvcmtmbG93LmVuYWJsZWQpIHtcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gd29ya2Zsb3cuc2NoZW1hIGFzIGFueTtcbiAgICAgICAgY29uc3QgaGFzQ3JvblRyaWdnZXIgPSBzY2hlbWE/LnRyaWdnZXJzPy5zb21lKFxuICAgICAgICAgICh0cmlnZ2VyOiBhbnkpID0+IFxuICAgICAgICAgICAgdHJpZ2dlci50eXBlID09PSAnY3JvbicgJiYgXG4gICAgICAgICAgICB0cmlnZ2VyLmNvbmZpZz8uc2NoZWR1bGVcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoaGFzQ3JvblRyaWdnZXIpIHtcbiAgICAgICAgICBhd2FpdCB0aGlzLnNjaGVkdWxlV29ya2Zsb3cod29ya2Zsb3cpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFxuICAgICAgICB7IGVycm9yLCB3b3JrZmxvd0lkIH0sXG4gICAgICAgICdGYWlsZWQgdG8gdXBkYXRlIHdvcmtmbG93IGNyb24gam9icycsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgY3JvbiBqb2JzIHdoZW4gYSB3b3JrZmxvdyBpcyBkZWxldGVkIG9yIGRpc2FibGVkXG4gICAqL1xuICBhc3luYyByZW1vdmVXb3JrZmxvd0Nyb25Kb2JzKHdvcmtmbG93SWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLnF1ZXVlU2VydmljZS5yZW1vdmVSZXBlYXRhYmxlSm9iKFxuICAgICAgICBRVUVVRV9OQU1FUy5ERUZBVUxULFxuICAgICAgICB3b3JrZmxvd0lkLFxuICAgICAgKTtcblxuICAgICAgdGhpcy5sb2dnZXIuaW5mbyhcbiAgICAgICAgeyB3b3JrZmxvd0lkIH0sXG4gICAgICAgICdSZW1vdmVkIGNyb24gam9icyBmb3Igd29ya2Zsb3cnLFxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXG4gICAgICAgIHsgZXJyb3IsIHdvcmtmbG93SWQgfSxcbiAgICAgICAgJ0ZhaWxlZCB0byByZW1vdmUgd29ya2Zsb3cgY3JvbiBqb2JzJyxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBjcm9uIGRyaWZ0IG1ldHJpY3MgZm9yIG1vbml0b3JpbmdcbiAgICovXG4gIGFzeW5jIGdldENyb25EcmlmdE1ldHJpY3MoKTogUHJvbWlzZTxcbiAgICBBcnJheTx7XG4gICAgICB3b3JrZmxvd0lkOiBzdHJpbmc7XG4gICAgICBzY2hlZHVsZTogc3RyaW5nO1xuICAgICAgbmV4dFJ1bjogRGF0ZTtcbiAgICAgIGRyaWZ0OiBudW1iZXI7XG4gICAgfT5cbiAgPiB7XG4gICAgY29uc3QgbWV0cmljcyA9IFtdO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXBlYXRhYmxlSm9icyA9IGF3YWl0IHRoaXMucXVldWVTZXJ2aWNlLmdldFJlcGVhdGFibGVKb2JzKFxuICAgICAgICBRVUVVRV9OQU1FUy5ERUZBVUxULFxuICAgICAgKTtcblxuICAgICAgZm9yIChjb25zdCBqb2Igb2YgcmVwZWF0YWJsZUpvYnMpIHtcbiAgICAgICAgaWYgKGpvYi5pZD8uc3RhcnRzV2l0aCgnY3Jvbi0nKSkge1xuICAgICAgICAgIGNvbnN0IHdvcmtmbG93SWQgPSBqb2IuaWQucmVwbGFjZSgnY3Jvbi0nLCAnJyk7XG4gICAgICAgICAgY29uc3QgbmV4dFJ1biA9IG5ldyBEYXRlKGpvYi5uZXh0KTtcbiAgICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgIGNvbnN0IGRyaWZ0ID0gbmV4dFJ1bi5nZXRUaW1lKCkgLSBub3cuZ2V0VGltZSgpO1xuXG4gICAgICAgICAgbWV0cmljcy5wdXNoKHtcbiAgICAgICAgICAgIHdvcmtmbG93SWQsXG4gICAgICAgICAgICBzY2hlZHVsZTogam9iLnBhdHRlcm4sXG4gICAgICAgICAgICBuZXh0UnVuLFxuICAgICAgICAgICAgZHJpZnQ6IE1hdGguYWJzKGRyaWZ0KSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcih7IGVycm9yIH0sICdGYWlsZWQgdG8gZ2V0IGNyb24gZHJpZnQgbWV0cmljcycpO1xuICAgIH1cblxuICAgIHJldHVybiBtZXRyaWNzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNjaGVkdWxlIGxvZyBwcnVuaW5nIGpvYiB0byBydW4gZGFpbHkgYXQgMiBBTSBVVENcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgc2NoZWR1bGVMb2dQcnVuaW5nKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzY2hlZHVsZSA9ICcwIDIgKiAqIConOyAvLyBEYWlseSBhdCAyIEFNIFVUQ1xuICAgICAgY29uc3Qgb2xkZXJUaGFuRGF5cyA9IDkwOyAvLyBEZWZhdWx0IHJldGVudGlvbiBwZXJpb2RcblxuICAgICAgYXdhaXQgdGhpcy5xdWV1ZVNlcnZpY2UuYWRkUmVwZWF0YWJsZUpvYihcbiAgICAgICAgUVVFVUVfTkFNRVMuREVGQVVMVCxcbiAgICAgICAgSk9CX05BTUVTLlBSVU5FX0xPR1MsXG4gICAgICAgIHtcbiAgICAgICAgICBvbGRlclRoYW5EYXlzLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgcGF0dGVybjogc2NoZWR1bGUsXG4gICAgICAgICAgdHo6ICdVVEMnLFxuICAgICAgICB9LFxuICAgICAgKTtcblxuICAgICAgdGhpcy5sb2dnZXIuaW5mbyhcbiAgICAgICAge1xuICAgICAgICAgIHNjaGVkdWxlLFxuICAgICAgICAgIG9sZGVyVGhhbkRheXMsXG4gICAgICAgIH0sXG4gICAgICAgICdTY2hlZHVsZWQgbG9nIHBydW5pbmcgam9iJyxcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFxuICAgICAgICB7IGVycm9yIH0sXG4gICAgICAgICdGYWlsZWQgdG8gc2NoZWR1bGUgbG9nIHBydW5pbmcgam9iJyxcbiAgICAgICk7XG4gICAgfVxuICB9XG59Il0sInZlcnNpb24iOjN9