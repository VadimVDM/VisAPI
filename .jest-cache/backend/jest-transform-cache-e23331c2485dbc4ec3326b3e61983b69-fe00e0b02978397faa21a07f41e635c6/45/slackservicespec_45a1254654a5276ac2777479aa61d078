8569b782922cca8040845790085e9ab2
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const testing_1 = require("@nestjs/testing");
const axios_1 = require("@nestjs/axios");
const core_config_1 = require("@visapi/core-config");
const slack_service_1 = require("./slack.service");
const rxjs_1 = require("rxjs");
const nestjs_pino_1 = require("nestjs-pino");
describe('SlackService', () => {
    let service;
    let httpService;
    let configService;
    let logger;
    const mockHttpService = {
        post: jest.fn(),
    };
    const mockConfigService = {
        slackEnabled: true,
        slackWebhookUrl: 'https://hooks.slack.com/services/test/webhook',
        slackDefaultChannel: '#alerts',
        slackSigningSecret: 'test-secret',
    };
    const mockLogger = {
        debug: jest.fn(),
        info: jest.fn(),
        error: jest.fn(),
        warn: jest.fn(),
    };
    beforeEach(() => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        const module = yield testing_1.Test.createTestingModule({
            providers: [
                slack_service_1.SlackService,
                {
                    provide: axios_1.HttpService,
                    useValue: mockHttpService,
                },
                {
                    provide: core_config_1.ConfigService,
                    useValue: mockConfigService,
                },
                {
                    provide: nestjs_pino_1.PinoLogger,
                    useValue: mockLogger,
                },
            ],
        }).compile();
        service = module.get(slack_service_1.SlackService);
        httpService = module.get(axios_1.HttpService);
        configService = module.get(core_config_1.ConfigService);
        logger = module.get(nestjs_pino_1.PinoLogger);
    }));
    afterEach(() => {
        jest.clearAllMocks();
    });
    it('should be defined', () => {
        expect(service).toBeDefined();
    });
    describe('sendGrafanaAlert', () => {
        const mockPayload = {
            dashboardId: 1,
            evalMatches: [
                {
                    value: 75.5,
                    metric: 'cpu_usage',
                    tags: { host: 'server-1' },
                },
            ],
            message: 'CPU usage is above threshold',
            orgId: 1,
            panelId: 2,
            ruleId: 3,
            ruleName: 'High CPU Usage',
            ruleUrl: 'https://grafana.example.com/d/dashboard/panel',
            state: 'alerting',
            tags: { severity: 'high' },
            title: 'High CPU Usage Alert',
        };
        it('should send Grafana alert successfully', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            mockHttpService.post.mockReturnValue((0, rxjs_1.of)({ data: { ok: true } }));
            yield service.sendGrafanaAlert(mockPayload);
            expect(mockHttpService.post).toHaveBeenCalledWith('https://hooks.slack.com/services/test/webhook', expect.objectContaining({
                channel: '#alerts',
                username: 'VisAPI Monitoring',
                icon_emoji: ':chart_with_upwards_trend:',
                text: expect.stringContaining('ALERTING'),
                attachments: expect.arrayContaining([
                    expect.objectContaining({
                        color: 'danger',
                        title: 'High CPU Usage',
                        title_link: 'https://grafana.example.com/d/dashboard/panel',
                        text: 'CPU usage is above threshold',
                    }),
                ]),
            }), expect.objectContaining({
                headers: {
                    'Content-Type': 'application/json',
                },
                timeout: 10000,
            }));
            expect(mockLogger.info).toHaveBeenCalledWith('Slack alert sent successfully', expect.objectContaining({
                ruleName: 'High CPU Usage',
                state: 'alerting',
            }));
        }));
        it('should skip alert when Slack is disabled', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            jest.spyOn(configService, 'slackEnabled', 'get').mockReturnValue(false);
            yield service.sendGrafanaAlert(mockPayload);
            expect(mockHttpService.post).not.toHaveBeenCalled();
            expect(mockLogger.debug).toHaveBeenCalledWith('Slack integration disabled, skipping alert');
        }));
        it('should handle missing webhook URL', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            jest.spyOn(configService, 'slackWebhookUrl', 'get').mockReturnValue('');
            yield service.sendGrafanaAlert(mockPayload);
            expect(mockHttpService.post).not.toHaveBeenCalled();
            expect(mockLogger.error).toHaveBeenCalledWith('Slack webhook URL not configured');
        }));
        it('should handle HTTP errors', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const error = new Error('Network error');
            mockHttpService.post.mockReturnValue((0, rxjs_1.of)().pipe(() => {
                throw error;
            }));
            yield expect(service.sendGrafanaAlert(mockPayload)).rejects.toThrow('Network error');
            expect(mockLogger.error).toHaveBeenCalledWith('Failed to send Slack alert', expect.objectContaining({
                error: 'Network error',
                ruleName: 'High CPU Usage',
                state: 'alerting',
            }));
        }));
        it('should format resolved alert correctly', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const resolvedPayload = Object.assign(Object.assign({}, mockPayload), { state: 'ok', message: 'CPU usage is back to normal' });
            mockHttpService.post.mockReturnValue((0, rxjs_1.of)({ data: { ok: true } }));
            yield service.sendGrafanaAlert(resolvedPayload);
            expect(mockHttpService.post).toHaveBeenCalledWith(expect.any(String), expect.objectContaining({
                text: expect.stringContaining('OK'),
                attachments: expect.arrayContaining([
                    expect.objectContaining({
                        color: 'good',
                        pretext: expect.stringContaining('OK Alert'),
                    }),
                ]),
            }), expect.any(Object));
        }));
    });
    describe('sendCustomAlert', () => {
        it('should send custom alert successfully', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            mockHttpService.post.mockReturnValue((0, rxjs_1.of)({ data: { ok: true } }));
            yield service.sendCustomAlert('Test message', 'warning', '#test');
            expect(mockHttpService.post).toHaveBeenCalledWith('https://hooks.slack.com/services/test/webhook', expect.objectContaining({
                channel: '#test',
                username: 'VisAPI System',
                icon_emoji: ':robot_face:',
                text: ':warning: Test message',
                attachments: expect.arrayContaining([
                    expect.objectContaining({
                        color: 'warning',
                        text: 'Test message',
                    }),
                ]),
            }), expect.objectContaining({
                headers: {
                    'Content-Type': 'application/json',
                },
                timeout: 10000,
            }));
            expect(mockLogger.info).toHaveBeenCalledWith('Custom Slack alert sent successfully', expect.objectContaining({
                severity: 'warning',
                channel: '#test',
            }));
        }));
        it('should use default channel when none specified', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            mockHttpService.post.mockReturnValue((0, rxjs_1.of)({ data: { ok: true } }));
            yield service.sendCustomAlert('Test message');
            expect(mockHttpService.post).toHaveBeenCalledWith(expect.any(String), expect.objectContaining({
                channel: '#alerts',
            }), expect.any(Object));
        }));
    });
    describe('validateWebhookSignature', () => {
        it('should return true for valid signature', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const payload = '{"test": "data"}';
            const timestamp = '1234567890';
            const crypto = require('crypto');
            const signature = 'v0=' + crypto
                .createHmac('sha256', 'test-secret')
                .update(`v0:${timestamp}:${payload}`)
                .digest('hex');
            const result = yield service.validateWebhookSignature(payload, timestamp, signature);
            expect(result).toBe(true);
        }));
        it('should return false for invalid signature', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const payload = '{"test": "data"}';
            const timestamp = '1234567890';
            const signature = 'v0=invalid_signature';
            const result = yield service.validateWebhookSignature(payload, timestamp, signature);
            expect(result).toBe(false);
        }));
        it('should return true when no signing secret is configured', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            jest.spyOn(configService, 'slackSigningSecret', 'get').mockReturnValue('');
            const result = yield service.validateWebhookSignature('payload', '123', 'sig');
            expect(result).toBe(true);
            expect(mockLogger.warn).toHaveBeenCalledWith('Slack signing secret not configured, skipping signature validation');
        }));
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL3ZhZGltL1Byb2plY3RzL1Zpc0FQSS9hcHBzL2JhY2tlbmQvc3JjL25vdGlmaWNhdGlvbnMvc2xhY2suc2VydmljZS5zcGVjLnRzIiwibWFwcGluZ3MiOiI7OztBQUFBLDZDQUFzRDtBQUN0RCx5Q0FBNEM7QUFDNUMscURBQW9EO0FBQ3BELG1EQUErQztBQUUvQywrQkFBMEI7QUFDMUIsNkNBQXlDO0FBRXpDLFFBQVEsQ0FBQyxjQUFjLEVBQUUsR0FBRyxFQUFFO0lBQzVCLElBQUksT0FBcUIsQ0FBQztJQUMxQixJQUFJLFdBQXdCLENBQUM7SUFDN0IsSUFBSSxhQUE0QixDQUFDO0lBQ2pDLElBQUksTUFBa0IsQ0FBQztJQUV2QixNQUFNLGVBQWUsR0FBRztRQUN0QixJQUFJLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRTtLQUNoQixDQUFDO0lBRUYsTUFBTSxpQkFBaUIsR0FBRztRQUN4QixZQUFZLEVBQUUsSUFBSTtRQUNsQixlQUFlLEVBQUUsK0NBQStDO1FBQ2hFLG1CQUFtQixFQUFFLFNBQVM7UUFDOUIsa0JBQWtCLEVBQUUsYUFBYTtLQUNsQyxDQUFDO0lBRUYsTUFBTSxVQUFVLEdBQUc7UUFDakIsS0FBSyxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUU7UUFDaEIsSUFBSSxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUU7UUFDZixLQUFLLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRTtRQUNoQixJQUFJLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRTtLQUNoQixDQUFDO0lBRUYsVUFBVSxDQUFDLEdBQVMsRUFBRTtRQUNwQixNQUFNLE1BQU0sR0FBa0IsTUFBTSxjQUFJLENBQUMsbUJBQW1CLENBQUM7WUFDM0QsU0FBUyxFQUFFO2dCQUNULDRCQUFZO2dCQUNaO29CQUNFLE9BQU8sRUFBRSxtQkFBVztvQkFDcEIsUUFBUSxFQUFFLGVBQWU7aUJBQzFCO2dCQUNEO29CQUNFLE9BQU8sRUFBRSwyQkFBYTtvQkFDdEIsUUFBUSxFQUFFLGlCQUFpQjtpQkFDNUI7Z0JBQ0Q7b0JB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QUFDLENBQUM7WUFFckYsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUM1QixDQUFDLENBQUEsQ0FBQyxDQUFDO1FBRUgsRUFBRSxDQUFDLDJDQUEyQyxFQUFFLEdBQVMsRUFBRTtZQUN6RCxNQUFNLE9BQU8sR0FBRyxrQkFBa0IsQ0FBQztZQUNuQyxNQUFNLFNBQVMsR0FBRyxZQUFZLENBQUM7WUFDL0IsTUFBTSxTQUFTLEdBQUcsc0JBQXNCLENBQUM7WUFFekMsTUFBTSxNQUFNLEdBQUcsTUFBTSxPQUFPLENBQUMsd0JBQXdCLENBQUMsT0FBTyxFQUFFLFNBQVMsRUFBRSxTQUFTLENBQUMsQ0FBQztZQUVyRixNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzdCLENBQUMsQ0FBQSxDQUFDLENBQUM7UUFFSCxFQUFFLENBQUMseURBQXlELEVBQUUsR0FBUyxFQUFFO1lBQ3ZFLElBQUksQ0FBQyxLQUFLLENBQUMsYUFBYSxFQUFFLG9CQUFvQixFQUFFLEtBQUssQ0FBQyxDQUFDLGVBQWUsQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUUzRSxNQUFNLE1BQU0sR0FBRyxNQUFNLE9BQU8sQ0FBQyx3QkFBd0IsQ0FBQyxTQUFTLEVBQUUsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDO1lBRS9FLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDMUIsTUFBTSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxvQkFBb0IsQ0FDMUMsb0VBQW9FLENBQ3JFLENBQUM7UUFDSixDQUFDLENBQUEsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUMsQ0FBQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyIvVXNlcnMvdmFkaW0vUHJvamVjdHMvVmlzQVBJL2FwcHMvYmFja2VuZC9zcmMvbm90aWZpY2F0aW9ucy9zbGFjay5zZXJ2aWNlLnNwZWMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVGVzdCwgVGVzdGluZ01vZHVsZSB9IGZyb20gJ0BuZXN0anMvdGVzdGluZyc7XG5pbXBvcnQgeyBIdHRwU2VydmljZSB9IGZyb20gJ0BuZXN0anMvYXhpb3MnO1xuaW1wb3J0IHsgQ29uZmlnU2VydmljZSB9IGZyb20gJ0B2aXNhcGkvY29yZS1jb25maWcnO1xuaW1wb3J0IHsgU2xhY2tTZXJ2aWNlIH0gZnJvbSAnLi9zbGFjay5zZXJ2aWNlJztcbmltcG9ydCB7IEdyYWZhbmFXZWJob29rUGF5bG9hZCB9IGZyb20gJ0B2aXNhcGkvc2hhcmVkLXR5cGVzJztcbmltcG9ydCB7IG9mIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBQaW5vTG9nZ2VyIH0gZnJvbSAnbmVzdGpzLXBpbm8nO1xuXG5kZXNjcmliZSgnU2xhY2tTZXJ2aWNlJywgKCkgPT4ge1xuICBsZXQgc2VydmljZTogU2xhY2tTZXJ2aWNlO1xuICBsZXQgaHR0cFNlcnZpY2U6IEh0dHBTZXJ2aWNlO1xuICBsZXQgY29uZmlnU2VydmljZTogQ29uZmlnU2VydmljZTtcbiAgbGV0IGxvZ2dlcjogUGlub0xvZ2dlcjtcblxuICBjb25zdCBtb2NrSHR0cFNlcnZpY2UgPSB7XG4gICAgcG9zdDogamVzdC5mbigpLFxuICB9O1xuXG4gIGNvbnN0IG1vY2tDb25maWdTZXJ2aWNlID0ge1xuICAgIHNsYWNrRW5hYmxlZDogdHJ1ZSxcbiAgICBzbGFja1dlYmhvb2tVcmw6ICdodHRwczovL2hvb2tzLnNsYWNrLmNvbS9zZXJ2aWNlcy90ZXN0L3dlYmhvb2snLFxuICAgIHNsYWNrRGVmYXVsdENoYW5uZWw6ICcjYWxlcnRzJyxcbiAgICBzbGFja1NpZ25pbmdTZWNyZXQ6ICd0ZXN0LXNlY3JldCcsXG4gIH07XG5cbiAgY29uc3QgbW9ja0xvZ2dlciA9IHtcbiAgICBkZWJ1ZzogamVzdC5mbigpLFxuICAgIGluZm86IGplc3QuZm4oKSxcbiAgICBlcnJvcjogamVzdC5mbigpLFxuICAgIHdhcm46IGplc3QuZm4oKSxcbiAgfTtcblxuICBiZWZvcmVFYWNoKGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBtb2R1bGU6IFRlc3RpbmdNb2R1bGUgPSBhd2FpdCBUZXN0LmNyZWF0ZVRlc3RpbmdNb2R1bGUoe1xuICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIFNsYWNrU2VydmljZSxcbiAgICAgICAge1xuICAgICAgICAgIHByb3ZpZGU6IEh0dHBTZXJ2aWNlLFxuICAgICAgICAgIHVzZVZhbHVlOiBtb2NrSHR0cFNlcnZpY2UsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBwcm92aWRlOiBDb25maWdTZXJ2aWNlLFxuICAgICAgICAgIHVzZVZhbHVlOiBtb2NrQ29uZmlnU2VydmljZSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHByb3ZpZGU6IFBpbm9Mb2dnZXIsXG4gICAgICAgICAgdXNlVmFsdWU6IG1vY2tMb2dnZXIsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgIH0pLmNvbXBpbGUoKTtcblxuICAgIHNlcnZpY2UgPSBtb2R1bGUuZ2V0PFNsYWNrU2VydmljZT4oU2xhY2tTZXJ2aWNlKTtcbiAgICBodHRwU2VydmljZSA9IG1vZHVsZS5nZXQ8SHR0cFNlcnZpY2U+KEh0dHBTZXJ2aWNlKTtcbiAgICBjb25maWdTZXJ2aWNlID0gbW9kdWxlLmdldDxDb25maWdTZXJ2aWNlPihDb25maWdTZXJ2aWNlKTtcbiAgICBsb2dnZXIgPSBtb2R1bGUuZ2V0PFBpbm9Mb2dnZXI+KFBpbm9Mb2dnZXIpO1xuICB9KTtcblxuICBhZnRlckVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIGJlIGRlZmluZWQnLCAoKSA9PiB7XG4gICAgZXhwZWN0KHNlcnZpY2UpLnRvQmVEZWZpbmVkKCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdzZW5kR3JhZmFuYUFsZXJ0JywgKCkgPT4ge1xuICAgIGNvbnN0IG1vY2tQYXlsb2FkOiBHcmFmYW5hV2ViaG9va1BheWxvYWQgPSB7XG4gICAgICBkYXNoYm9hcmRJZDogMSxcbiAgICAgIGV2YWxNYXRjaGVzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICB2YWx1ZTogNzUuNSxcbiAgICAgICAgICBtZXRyaWM6ICdjcHVfdXNhZ2UnLFxuICAgICAgICAgIHRhZ3M6IHsgaG9zdDogJ3NlcnZlci0xJyB9LFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICAgIG1lc3NhZ2U6ICdDUFUgdXNhZ2UgaXMgYWJvdmUgdGhyZXNob2xkJyxcbiAgICAgIG9yZ0lkOiAxLFxuICAgICAgcGFuZWxJZDogMixcbiAgICAgIHJ1bGVJZDogMyxcbiAgICAgIHJ1bGVOYW1lOiAnSGlnaCBDUFUgVXNhZ2UnLFxuICAgICAgcnVsZVVybDogJ2h0dHBzOi8vZ3JhZmFuYS5leGFtcGxlLmNvbS9kL2Rhc2hib2FyZC9wYW5lbCcsXG4gICAgICBzdGF0ZTogJ2FsZXJ0aW5nJyxcbiAgICAgIHRhZ3M6IHsgc2V2ZXJpdHk6ICdoaWdoJyB9LFxuICAgICAgdGl0bGU6ICdIaWdoIENQVSBVc2FnZSBBbGVydCcsXG4gICAgfTtcblxuICAgIGl0KCdzaG91bGQgc2VuZCBHcmFmYW5hIGFsZXJ0IHN1Y2Nlc3NmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tIdHRwU2VydmljZS5wb3N0Lm1vY2tSZXR1cm5WYWx1ZShvZih7IGRhdGE6IHsgb2s6IHRydWUgfSB9KSk7XG5cbiAgICAgIGF3YWl0IHNlcnZpY2Uuc2VuZEdyYWZhbmFBbGVydChtb2NrUGF5bG9hZCk7XG5cbiAgICAgIGV4cGVjdChtb2NrSHR0cFNlcnZpY2UucG9zdCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICdodHRwczovL2hvb2tzLnNsYWNrLmNvbS9zZXJ2aWNlcy90ZXN0L3dlYmhvb2snLFxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgY2hhbm5lbDogJyNhbGVydHMnLFxuICAgICAgICAgIHVzZXJuYW1lOiAnVmlzQVBJIE1vbml0b3JpbmcnLFxuICAgICAgICAgIGljb25fZW1vamk6ICc6Y2hhcnRfd2l0aF91cHdhcmRzX3RyZW5kOicsXG4gICAgICAgICAgdGV4dDogZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ0FMRVJUSU5HJyksXG4gICAgICAgICAgYXR0YWNobWVudHM6IGV4cGVjdC5hcnJheUNvbnRhaW5pbmcoW1xuICAgICAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgICAgICBjb2xvcjogJ2RhbmdlcicsXG4gICAgICAgICAgICAgIHRpdGxlOiAnSGlnaCBDUFUgVXNhZ2UnLFxuICAgICAgICAgICAgICB0aXRsZV9saW5rOiAnaHR0cHM6Ly9ncmFmYW5hLmV4YW1wbGUuY29tL2QvZGFzaGJvYXJkL3BhbmVsJyxcbiAgICAgICAgICAgICAgdGV4dDogJ0NQVSB1c2FnZSBpcyBhYm92ZSB0aHJlc2hvbGQnLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgXSksXG4gICAgICAgIH0pLFxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRpbWVvdXQ6IDEwMDAwLFxuICAgICAgICB9KVxuICAgICAgKTtcblxuICAgICAgZXhwZWN0KG1vY2tMb2dnZXIuaW5mbykudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICdTbGFjayBhbGVydCBzZW50IHN1Y2Nlc3NmdWxseScsXG4gICAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgICBydWxlTmFtZTogJ0hpZ2ggQ1BVIFVzYWdlJyxcbiAgICAgICAgICBzdGF0ZTogJ2FsZXJ0aW5nJyxcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHNraXAgYWxlcnQgd2hlbiBTbGFjayBpcyBkaXNhYmxlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGplc3Quc3B5T24oY29uZmlnU2VydmljZSwgJ3NsYWNrRW5hYmxlZCcsICdnZXQnKS5tb2NrUmV0dXJuVmFsdWUoZmFsc2UpO1xuXG4gICAgICBhd2FpdCBzZXJ2aWNlLnNlbmRHcmFmYW5hQWxlcnQobW9ja1BheWxvYWQpO1xuXG4gICAgICBleHBlY3QobW9ja0h0dHBTZXJ2aWNlLnBvc3QpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICBleHBlY3QobW9ja0xvZ2dlci5kZWJ1ZykudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICdTbGFjayBpbnRlZ3JhdGlvbiBkaXNhYmxlZCwgc2tpcHBpbmcgYWxlcnQnXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbWlzc2luZyB3ZWJob29rIFVSTCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGplc3Quc3B5T24oY29uZmlnU2VydmljZSwgJ3NsYWNrV2ViaG9va1VybCcsICdnZXQnKS5tb2NrUmV0dXJuVmFsdWUoJycpO1xuXG4gICAgICBhd2FpdCBzZXJ2aWNlLnNlbmRHcmFmYW5hQWxlcnQobW9ja1BheWxvYWQpO1xuXG4gICAgICBleHBlY3QobW9ja0h0dHBTZXJ2aWNlLnBvc3QpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICBleHBlY3QobW9ja0xvZ2dlci5lcnJvcikudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICdTbGFjayB3ZWJob29rIFVSTCBub3QgY29uZmlndXJlZCdcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBIVFRQIGVycm9ycycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdOZXR3b3JrIGVycm9yJyk7XG4gICAgICBtb2NrSHR0cFNlcnZpY2UucG9zdC5tb2NrUmV0dXJuVmFsdWUoXG4gICAgICAgIG9mKCkucGlwZSgoKSA9PiB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pXG4gICAgICApO1xuXG4gICAgICBhd2FpdCBleHBlY3Qoc2VydmljZS5zZW5kR3JhZmFuYUFsZXJ0KG1vY2tQYXlsb2FkKSkucmVqZWN0cy50b1Rocm93KFxuICAgICAgICAnTmV0d29yayBlcnJvcidcbiAgICAgICk7XG5cbiAgICAgIGV4cGVjdChtb2NrTG9nZ2VyLmVycm9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgJ0ZhaWxlZCB0byBzZW5kIFNsYWNrIGFsZXJ0JyxcbiAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgIGVycm9yOiAnTmV0d29yayBlcnJvcicsXG4gICAgICAgICAgcnVsZU5hbWU6ICdIaWdoIENQVSBVc2FnZScsXG4gICAgICAgICAgc3RhdGU6ICdhbGVydGluZycsXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBmb3JtYXQgcmVzb2x2ZWQgYWxlcnQgY29ycmVjdGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzb2x2ZWRQYXlsb2FkOiBHcmFmYW5hV2ViaG9va1BheWxvYWQgPSB7XG4gICAgICAgIC4uLm1vY2tQYXlsb2FkLFxuICAgICAgICBzdGF0ZTogJ29rJyxcbiAgICAgICAgbWVzc2FnZTogJ0NQVSB1c2FnZSBpcyBiYWNrIHRvIG5vcm1hbCcsXG4gICAgICB9O1xuXG4gICAgICBtb2NrSHR0cFNlcnZpY2UucG9zdC5tb2NrUmV0dXJuVmFsdWUob2YoeyBkYXRhOiB7IG9rOiB0cnVlIH0gfSkpO1xuXG4gICAgICBhd2FpdCBzZXJ2aWNlLnNlbmRHcmFmYW5hQWxlcnQocmVzb2x2ZWRQYXlsb2FkKTtcblxuICAgICAgZXhwZWN0KG1vY2tIdHRwU2VydmljZS5wb3N0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgZXhwZWN0LmFueShTdHJpbmcpLFxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgdGV4dDogZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ09LJyksXG4gICAgICAgICAgYXR0YWNobWVudHM6IGV4cGVjdC5hcnJheUNvbnRhaW5pbmcoW1xuICAgICAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgICAgICBjb2xvcjogJ2dvb2QnLFxuICAgICAgICAgICAgICBwcmV0ZXh0OiBleHBlY3Quc3RyaW5nQ29udGFpbmluZygnT0sgQWxlcnQnKSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgIF0pLFxuICAgICAgICB9KSxcbiAgICAgICAgZXhwZWN0LmFueShPYmplY3QpXG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnc2VuZEN1c3RvbUFsZXJ0JywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgc2VuZCBjdXN0b20gYWxlcnQgc3VjY2Vzc2Z1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0h0dHBTZXJ2aWNlLnBvc3QubW9ja1JldHVyblZhbHVlKG9mKHsgZGF0YTogeyBvazogdHJ1ZSB9IH0pKTtcblxuICAgICAgYXdhaXQgc2VydmljZS5zZW5kQ3VzdG9tQWxlcnQoJ1Rlc3QgbWVzc2FnZScsICd3YXJuaW5nJywgJyN0ZXN0Jyk7XG5cbiAgICAgIGV4cGVjdChtb2NrSHR0cFNlcnZpY2UucG9zdCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICdodHRwczovL2hvb2tzLnNsYWNrLmNvbS9zZXJ2aWNlcy90ZXN0L3dlYmhvb2snLFxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgY2hhbm5lbDogJyN0ZXN0JyxcbiAgICAgICAgICB1c2VybmFtZTogJ1Zpc0FQSSBTeXN0ZW0nLFxuICAgICAgICAgIGljb25fZW1vamk6ICc6cm9ib3RfZmFjZTonLFxuICAgICAgICAgIHRleHQ6ICc6d2FybmluZzogVGVzdCBtZXNzYWdlJyxcbiAgICAgICAgICBhdHRhY2htZW50czogZXhwZWN0LmFycmF5Q29udGFpbmluZyhbXG4gICAgICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgICAgIGNvbG9yOiAnd2FybmluZycsXG4gICAgICAgICAgICAgIHRleHQ6ICdUZXN0IG1lc3NhZ2UnLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgXSksXG4gICAgICAgIH0pLFxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRpbWVvdXQ6IDEwMDAwLFxuICAgICAgICB9KVxuICAgICAgKTtcblxuICAgICAgZXhwZWN0KG1vY2tMb2dnZXIuaW5mbykudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICdDdXN0b20gU2xhY2sgYWxlcnQgc2VudCBzdWNjZXNzZnVsbHknLFxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgc2V2ZXJpdHk6ICd3YXJuaW5nJyxcbiAgICAgICAgICBjaGFubmVsOiAnI3Rlc3QnLFxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdXNlIGRlZmF1bHQgY2hhbm5lbCB3aGVuIG5vbmUgc3BlY2lmaWVkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0h0dHBTZXJ2aWNlLnBvc3QubW9ja1JldHVyblZhbHVlKG9mKHsgZGF0YTogeyBvazogdHJ1ZSB9IH0pKTtcblxuICAgICAgYXdhaXQgc2VydmljZS5zZW5kQ3VzdG9tQWxlcnQoJ1Rlc3QgbWVzc2FnZScpO1xuXG4gICAgICBleHBlY3QobW9ja0h0dHBTZXJ2aWNlLnBvc3QpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBleHBlY3QuYW55KFN0cmluZyksXG4gICAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgICBjaGFubmVsOiAnI2FsZXJ0cycsXG4gICAgICAgIH0pLFxuICAgICAgICBleHBlY3QuYW55KE9iamVjdClcbiAgICAgICk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCd2YWxpZGF0ZVdlYmhvb2tTaWduYXR1cmUnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gdHJ1ZSBmb3IgdmFsaWQgc2lnbmF0dXJlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcGF5bG9hZCA9ICd7XCJ0ZXN0XCI6IFwiZGF0YVwifSc7XG4gICAgICBjb25zdCB0aW1lc3RhbXAgPSAnMTIzNDU2Nzg5MCc7XG4gICAgICBjb25zdCBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9ICd2MD0nICsgY3J5cHRvXG4gICAgICAgIC5jcmVhdGVIbWFjKCdzaGEyNTYnLCAndGVzdC1zZWNyZXQnKVxuICAgICAgICAudXBkYXRlKGB2MDoke3RpbWVzdGFtcH06JHtwYXlsb2FkfWApXG4gICAgICAgIC5kaWdlc3QoJ2hleCcpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzZXJ2aWNlLnZhbGlkYXRlV2ViaG9va1NpZ25hdHVyZShwYXlsb2FkLCB0aW1lc3RhbXAsIHNpZ25hdHVyZSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBmYWxzZSBmb3IgaW52YWxpZCBzaWduYXR1cmUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBwYXlsb2FkID0gJ3tcInRlc3RcIjogXCJkYXRhXCJ9JztcbiAgICAgIGNvbnN0IHRpbWVzdGFtcCA9ICcxMjM0NTY3ODkwJztcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9ICd2MD1pbnZhbGlkX3NpZ25hdHVyZSc7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNlcnZpY2UudmFsaWRhdGVXZWJob29rU2lnbmF0dXJlKHBheWxvYWQsIHRpbWVzdGFtcCwgc2lnbmF0dXJlKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZShmYWxzZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiB0cnVlIHdoZW4gbm8gc2lnbmluZyBzZWNyZXQgaXMgY29uZmlndXJlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGplc3Quc3B5T24oY29uZmlnU2VydmljZSwgJ3NsYWNrU2lnbmluZ1NlY3JldCcsICdnZXQnKS5tb2NrUmV0dXJuVmFsdWUoJycpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzZXJ2aWNlLnZhbGlkYXRlV2ViaG9va1NpZ25hdHVyZSgncGF5bG9hZCcsICcxMjMnLCAnc2lnJyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QobW9ja0xvZ2dlci53YXJuKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgJ1NsYWNrIHNpZ25pbmcgc2VjcmV0IG5vdCBjb25maWd1cmVkLCBza2lwcGluZyBzaWduYXR1cmUgdmFsaWRhdGlvbidcbiAgICAgICk7XG4gICAgfSk7XG4gIH0pO1xufSk7Il0sInZlcnNpb24iOjN9