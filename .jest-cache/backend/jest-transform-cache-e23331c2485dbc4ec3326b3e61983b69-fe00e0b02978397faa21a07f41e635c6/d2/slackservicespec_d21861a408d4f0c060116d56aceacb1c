ecd8106f26e96d7922beb4f83c58cc3e
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const testing_1 = require("@nestjs/testing");
const axios_1 = require("@nestjs/axios");
const core_config_1 = require("@visapi/core-config");
const slack_service_1 = require("./slack.service");
const rxjs_1 = require("rxjs");
describe('SlackService', () => {
    let service;
    let httpService;
    let configService;
    let logger;
    const mockHttpService = {
        post: jest.fn(),
    };
    const mockConfigService = {
        slackEnabled: true,
        slackWebhookUrl: 'https://hooks.slack.com/services/test/webhook',
        slackDefaultChannel: '#alerts',
        slackSigningSecret: 'test-secret',
    };
    const mockLogger = {
        debug: jest.fn(),
        info: jest.fn(),
        error: jest.fn(),
        warn: jest.fn(),
    };
    beforeEach(() => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        const module = yield testing_1.Test.createTestingModule({
            providers: [
                slack_service_1.SlackService,
                {
                    provide: axios_1.HttpService,
                    useValue: mockHttpService,
                },
                {
                    provide: core_config_1.ConfigService,
                    useValue: mockConfigService,
                },
                {
                    provide: `PinoLogger:${slack_service_1.SlackService.name}`,
                    useValue: mockLogger,
                },
            ],
        }).compile();
        service = module.get(slack_service_1.SlackService);
        httpService = module.get(axios_1.HttpService);
        configService = module.get(core_config_1.ConfigService);
        logger = module.get(`PinoLogger:${slack_service_1.SlackService.name}`);
    }));
    afterEach(() => {
        jest.clearAllMocks();
    });
    it('should be defined', () => {
        expect(service).toBeDefined();
    });
    describe('sendGrafanaAlert', () => {
        const mockPayload = {
            dashboardId: 1,
            evalMatches: [
                {
                    value: 75.5,
                    metric: 'cpu_usage',
                    tags: { host: 'server-1' },
                },
            ],
            message: 'CPU usage is above threshold',
            orgId: 1,
            panelId: 2,
            ruleId: 3,
            ruleName: 'High CPU Usage',
            ruleUrl: 'https://grafana.example.com/d/dashboard/panel',
            state: 'alerting',
            tags: { severity: 'high' },
            title: 'High CPU Usage Alert',
        };
        it('should send Grafana alert successfully', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            mockHttpService.post.mockReturnValue((0, rxjs_1.of)({ data: { ok: true } }));
            yield service.sendGrafanaAlert(mockPayload);
            expect(mockHttpService.post).toHaveBeenCalledWith('https://hooks.slack.com/services/test/webhook', expect.objectContaining({
                channel: '#alerts',
                username: 'VisAPI Monitoring',
                icon_emoji: ':chart_with_upwards_trend:',
                text: expect.stringContaining('ALERTING'),
                attachments: expect.arrayContaining([
                    expect.objectContaining({
                        color: 'danger',
                        title: 'High CPU Usage',
                        title_link: 'https://grafana.example.com/d/dashboard/panel',
                        text: 'CPU usage is above threshold',
                    }),
                ]),
            }), expect.objectContaining({
                headers: {
                    'Content-Type': 'application/json',
                },
                timeout: 10000,
            }));
            expect(mockLogger.info).toHaveBeenCalledWith('Slack alert sent successfully', expect.objectContaining({
                ruleName: 'High CPU Usage',
                state: 'alerting',
            }));
        }));
        it('should skip alert when Slack is disabled', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            jest.spyOn(configService, 'slackEnabled', 'get').mockReturnValue(false);
            yield service.sendGrafanaAlert(mockPayload);
            expect(mockHttpService.post).not.toHaveBeenCalled();
            expect(mockLogger.debug).toHaveBeenCalledWith('Slack integration disabled, skipping alert');
        }));
        it('should handle missing webhook URL', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            jest.spyOn(configService, 'slackWebhookUrl', 'get').mockReturnValue('');
            yield service.sendGrafanaAlert(mockPayload);
            expect(mockHttpService.post).not.toHaveBeenCalled();
            expect(mockLogger.error).toHaveBeenCalledWith('Slack webhook URL not configured');
        }));
        it('should handle HTTP errors', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const error = new Error('Network error');
            mockHttpService.post.mockReturnValue((0, rxjs_1.of)().pipe(() => {
                throw error;
            }));
            yield expect(service.sendGrafanaAlert(mockPayload)).rejects.toThrow('Network error');
            expect(mockLogger.error).toHaveBeenCalledWith('Failed to send Slack alert', expect.objectContaining({
                error: 'Network error',
                ruleName: 'High CPU Usage',
                state: 'alerting',
            }));
        }));
        it('should format resolved alert correctly', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const resolvedPayload = Object.assign(Object.assign({}, mockPayload), { state: 'ok', message: 'CPU usage is back to normal' });
            mockHttpService.post.mockReturnValue((0, rxjs_1.of)({ data: { ok: true } }));
            yield service.sendGrafanaAlert(resolvedPayload);
            expect(mockHttpService.post).toHaveBeenCalledWith(expect.any(String), expect.objectContaining({
                text: expect.stringContaining('OK'),
                attachments: expect.arrayContaining([
                    expect.objectContaining({
                        color: 'good',
                        pretext: expect.stringContaining('OK Alert'),
                    }),
                ]),
            }), expect.any(Object));
        }));
    });
    describe('sendCustomAlert', () => {
        it('should send custom alert successfully', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            mockHttpService.post.mockReturnValue((0, rxjs_1.of)({ data: { ok: true } }));
            yield service.sendCustomAlert('Test message', 'warning', '#test');
            expect(mockHttpService.post).toHaveBeenCalledWith('https://hooks.slack.com/services/test/webhook', expect.objectContaining({
                channel: '#test',
                username: 'VisAPI System',
                icon_emoji: ':robot_face:',
                text: ':warning: Test message',
                attachments: expect.arrayContaining([
                    expect.objectContaining({
                        color: 'warning',
                        text: 'Test message',
                    }),
                ]),
            }), expect.objectContaining({
                headers: {
                    'Content-Type': 'application/json',
                },
                timeout: 10000,
            }));
            expect(mockLogger.info).toHaveBeenCalledWith('Custom Slack alert sent successfully', expect.objectContaining({
                severity: 'warning',
                channel: '#test',
            }));
        }));
        it('should use default channel when none specified', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            mockHttpService.post.mockReturnValue((0, rxjs_1.of)({ data: { ok: true } }));
            yield service.sendCustomAlert('Test message');
            expect(mockHttpService.post).toHaveBeenCalledWith(expect.any(String), expect.objectContaining({
                channel: '#alerts',
            }), expect.any(Object));
        }));
    });
    describe('validateWebhookSignature', () => {
        it('should return true for valid signature', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const payload = '{"test": "data"}';
            const timestamp = '1234567890';
            const crypto = require('crypto');
            const signature = 'v0=' + crypto
                .createHmac('sha256', 'test-secret')
                .update(`v0:${timestamp}:${payload}`)
                .digest('hex');
            const result = yield service.validateWebhookSignature(payload, timestamp, signature);
            expect(result).toBe(true);
        }));
        it('should return false for invalid signature', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const payload = '{"test": "data"}';
            const timestamp = '1234567890';
            const signature = 'v0=invalid_signature';
            const result = yield service.validateWebhookSignature(payload, timestamp, signature);
            expect(result).toBe(false);
        }));
        it('should return true when no signing secret is configured', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            jest.spyOn(configService, 'slackSigningSecret', 'get').mockReturnValue('');
            const result = yield service.validateWebhookSignature('payload', '123', 'sig');
            expect(result).toBe(true);
            expect(mockLogger.warn).toHaveBeenCalledWith('Slack signing secret not configured, skipping signature validation');
        }));
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL3ZhZGltL1Byb2plY3RzL1Zpc0FQSS9hcHBzL2JhY2tlbmQvc3JjL25vdGlmaWNhdGlvbnMvc2xhY2suc2VydmljZS5zcGVjLnRzIiwibWFwcGluZ3MiOiI7OztBQUFBLDZDQUFzRDtBQUN0RCx5Q0FBNEM7QUFDNUMscURBQW9EO0FBQ3BELG1EQUErQztBQUUvQywrQkFBMEI7QUFHMUIsUUFBUSxDQUFDLGNBQWMsRUFBRSxHQUFHLEVBQUU7SUFDNUIsSUFBSSxPQUFxQixDQUFDO0lBQzFCLElBQUksV0FBd0IsQ0FBQztJQUM3QixJQUFJLGFBQTRCLENBQUM7SUFDakMsSUFBSSxNQUFrQixDQUFDO0lBRXZCLE1BQU0sZUFBZSxHQUFHO1FBQ3RCLElBQUksRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO0tBQ2hCLENBQUM7SUFFRixNQUFNLGlCQUFpQixHQUFHO1FBQ3hCLFlBQVksRUFBRSxJQUFJO1FBQ2xCLGVBQWUsRUFBRSwrQ0FBK0M7UUFDaEUsbUJBQW1CLEVBQUUsU0FBUztRQUM5QixrQkFBa0IsRUFBRSxhQUFhO0tBQ2xDLENBQUM7SUFFRixNQUFNLFVBQVUsR0FBRztRQUNqQixLQUFLLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRTtRQUNoQixJQUFJLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRTtRQUNmLEtBQUssRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO1FBQ2hCLElBQUksRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO0tBQ2hCLENBQUM7SUFFRixVQUFVLENBQUMsR0FBUyxFQUFFO1FBQ3BCLE1BQU0sTUFBTSxHQUFrQixNQUFNLGNBQUksQ0FBQyxtQkFBbUIsQ0FBQztZQUMzRCxTQUFTLEVBQUU7Z0JBQ1QsNEJBQVk7Z0JBQ1o7b0JBQ0UsT0FBTyxFQUFFLG1CQUFXO29CQUNwQixRQUFRLEVBQUUsZUFBZTtpQkFDMUI7Z0JBQ0Q7b0JBQ0UsT0FBTyxFQUFFLDJCQUFhO29CQUN0QixRQUFRLEVBQUUsaUJBQWlCO2lCQUM1QjtnQkFDRDtvQkFDRSxPQUFPLEVBQUUs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LE9BQU8sRUFBRSxTQUFTLEVBQUUsU0FBUyxDQUFDLENBQUM7WUFFckYsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUM1QixDQUFDLENBQUEsQ0FBQyxDQUFDO1FBRUgsRUFBRSxDQUFDLDJDQUEyQyxFQUFFLEdBQVMsRUFBRTtZQUN6RCxNQUFNLE9BQU8sR0FBRyxrQkFBa0IsQ0FBQztZQUNuQyxNQUFNLFNBQVMsR0FBRyxZQUFZLENBQUM7WUFDL0IsTUFBTSxTQUFTLEdBQUcsc0JBQXNCLENBQUM7WUFFekMsTUFBTSxNQUFNLEdBQUcsTUFBTSxPQUFPLENBQUMsd0JBQXdCLENBQUMsT0FBTyxFQUFFLFNBQVMsRUFBRSxTQUFTLENBQUMsQ0FBQztZQUVyRixNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzdCLENBQUMsQ0FBQSxDQUFDLENBQUM7UUFFSCxFQUFFLENBQUMseURBQXlELEVBQUUsR0FBUyxFQUFFO1lBQ3ZFLElBQUksQ0FBQyxLQUFLLENBQUMsYUFBYSxFQUFFLG9CQUFvQixFQUFFLEtBQUssQ0FBQyxDQUFDLGVBQWUsQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUUzRSxNQUFNLE1BQU0sR0FBRyxNQUFNLE9BQU8sQ0FBQyx3QkFBd0IsQ0FBQyxTQUFTLEVBQUUsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDO1lBRS9FLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDMUIsTUFBTSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxvQkFBb0IsQ0FDMUMsb0VBQW9FLENBQ3JFLENBQUM7UUFDSixDQUFDLENBQUEsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUMsQ0FBQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyIvVXNlcnMvdmFkaW0vUHJvamVjdHMvVmlzQVBJL2FwcHMvYmFja2VuZC9zcmMvbm90aWZpY2F0aW9ucy9zbGFjay5zZXJ2aWNlLnNwZWMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVGVzdCwgVGVzdGluZ01vZHVsZSB9IGZyb20gJ0BuZXN0anMvdGVzdGluZyc7XG5pbXBvcnQgeyBIdHRwU2VydmljZSB9IGZyb20gJ0BuZXN0anMvYXhpb3MnO1xuaW1wb3J0IHsgQ29uZmlnU2VydmljZSB9IGZyb20gJ0B2aXNhcGkvY29yZS1jb25maWcnO1xuaW1wb3J0IHsgU2xhY2tTZXJ2aWNlIH0gZnJvbSAnLi9zbGFjay5zZXJ2aWNlJztcbmltcG9ydCB7IEdyYWZhbmFXZWJob29rUGF5bG9hZCB9IGZyb20gJ0B2aXNhcGkvc2hhcmVkLXR5cGVzJztcbmltcG9ydCB7IG9mIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBQaW5vTG9nZ2VyIH0gZnJvbSAnbmVzdGpzLXBpbm8nO1xuXG5kZXNjcmliZSgnU2xhY2tTZXJ2aWNlJywgKCkgPT4ge1xuICBsZXQgc2VydmljZTogU2xhY2tTZXJ2aWNlO1xuICBsZXQgaHR0cFNlcnZpY2U6IEh0dHBTZXJ2aWNlO1xuICBsZXQgY29uZmlnU2VydmljZTogQ29uZmlnU2VydmljZTtcbiAgbGV0IGxvZ2dlcjogUGlub0xvZ2dlcjtcblxuICBjb25zdCBtb2NrSHR0cFNlcnZpY2UgPSB7XG4gICAgcG9zdDogamVzdC5mbigpLFxuICB9O1xuXG4gIGNvbnN0IG1vY2tDb25maWdTZXJ2aWNlID0ge1xuICAgIHNsYWNrRW5hYmxlZDogdHJ1ZSxcbiAgICBzbGFja1dlYmhvb2tVcmw6ICdodHRwczovL2hvb2tzLnNsYWNrLmNvbS9zZXJ2aWNlcy90ZXN0L3dlYmhvb2snLFxuICAgIHNsYWNrRGVmYXVsdENoYW5uZWw6ICcjYWxlcnRzJyxcbiAgICBzbGFja1NpZ25pbmdTZWNyZXQ6ICd0ZXN0LXNlY3JldCcsXG4gIH07XG5cbiAgY29uc3QgbW9ja0xvZ2dlciA9IHtcbiAgICBkZWJ1ZzogamVzdC5mbigpLFxuICAgIGluZm86IGplc3QuZm4oKSxcbiAgICBlcnJvcjogamVzdC5mbigpLFxuICAgIHdhcm46IGplc3QuZm4oKSxcbiAgfTtcblxuICBiZWZvcmVFYWNoKGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBtb2R1bGU6IFRlc3RpbmdNb2R1bGUgPSBhd2FpdCBUZXN0LmNyZWF0ZVRlc3RpbmdNb2R1bGUoe1xuICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIFNsYWNrU2VydmljZSxcbiAgICAgICAge1xuICAgICAgICAgIHByb3ZpZGU6IEh0dHBTZXJ2aWNlLFxuICAgICAgICAgIHVzZVZhbHVlOiBtb2NrSHR0cFNlcnZpY2UsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBwcm92aWRlOiBDb25maWdTZXJ2aWNlLFxuICAgICAgICAgIHVzZVZhbHVlOiBtb2NrQ29uZmlnU2VydmljZSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHByb3ZpZGU6IGBQaW5vTG9nZ2VyOiR7U2xhY2tTZXJ2aWNlLm5hbWV9YCxcbiAgICAgICAgICB1c2VWYWx1ZTogbW9ja0xvZ2dlcixcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgfSkuY29tcGlsZSgpO1xuXG4gICAgc2VydmljZSA9IG1vZHVsZS5nZXQ8U2xhY2tTZXJ2aWNlPihTbGFja1NlcnZpY2UpO1xuICAgIGh0dHBTZXJ2aWNlID0gbW9kdWxlLmdldDxIdHRwU2VydmljZT4oSHR0cFNlcnZpY2UpO1xuICAgIGNvbmZpZ1NlcnZpY2UgPSBtb2R1bGUuZ2V0PENvbmZpZ1NlcnZpY2U+KENvbmZpZ1NlcnZpY2UpO1xuICAgIGxvZ2dlciA9IG1vZHVsZS5nZXQ8UGlub0xvZ2dlcj4oYFBpbm9Mb2dnZXI6JHtTbGFja1NlcnZpY2UubmFtZX1gKTtcbiAgfSk7XG5cbiAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBiZSBkZWZpbmVkJywgKCkgPT4ge1xuICAgIGV4cGVjdChzZXJ2aWNlKS50b0JlRGVmaW5lZCgpO1xuICB9KTtcblxuICBkZXNjcmliZSgnc2VuZEdyYWZhbmFBbGVydCcsICgpID0+IHtcbiAgICBjb25zdCBtb2NrUGF5bG9hZDogR3JhZmFuYVdlYmhvb2tQYXlsb2FkID0ge1xuICAgICAgZGFzaGJvYXJkSWQ6IDEsXG4gICAgICBldmFsTWF0Y2hlczogW1xuICAgICAgICB7XG4gICAgICAgICAgdmFsdWU6IDc1LjUsXG4gICAgICAgICAgbWV0cmljOiAnY3B1X3VzYWdlJyxcbiAgICAgICAgICB0YWdzOiB7IGhvc3Q6ICdzZXJ2ZXItMScgfSxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICBtZXNzYWdlOiAnQ1BVIHVzYWdlIGlzIGFib3ZlIHRocmVzaG9sZCcsXG4gICAgICBvcmdJZDogMSxcbiAgICAgIHBhbmVsSWQ6IDIsXG4gICAgICBydWxlSWQ6IDMsXG4gICAgICBydWxlTmFtZTogJ0hpZ2ggQ1BVIFVzYWdlJyxcbiAgICAgIHJ1bGVVcmw6ICdodHRwczovL2dyYWZhbmEuZXhhbXBsZS5jb20vZC9kYXNoYm9hcmQvcGFuZWwnLFxuICAgICAgc3RhdGU6ICdhbGVydGluZycsXG4gICAgICB0YWdzOiB7IHNldmVyaXR5OiAnaGlnaCcgfSxcbiAgICAgIHRpdGxlOiAnSGlnaCBDUFUgVXNhZ2UgQWxlcnQnLFxuICAgIH07XG5cbiAgICBpdCgnc2hvdWxkIHNlbmQgR3JhZmFuYSBhbGVydCBzdWNjZXNzZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrSHR0cFNlcnZpY2UucG9zdC5tb2NrUmV0dXJuVmFsdWUob2YoeyBkYXRhOiB7IG9rOiB0cnVlIH0gfSkpO1xuXG4gICAgICBhd2FpdCBzZXJ2aWNlLnNlbmRHcmFmYW5hQWxlcnQobW9ja1BheWxvYWQpO1xuXG4gICAgICBleHBlY3QobW9ja0h0dHBTZXJ2aWNlLnBvc3QpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAnaHR0cHM6Ly9ob29rcy5zbGFjay5jb20vc2VydmljZXMvdGVzdC93ZWJob29rJyxcbiAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgIGNoYW5uZWw6ICcjYWxlcnRzJyxcbiAgICAgICAgICB1c2VybmFtZTogJ1Zpc0FQSSBNb25pdG9yaW5nJyxcbiAgICAgICAgICBpY29uX2Vtb2ppOiAnOmNoYXJ0X3dpdGhfdXB3YXJkc190cmVuZDonLFxuICAgICAgICAgIHRleHQ6IGV4cGVjdC5zdHJpbmdDb250YWluaW5nKCdBTEVSVElORycpLFxuICAgICAgICAgIGF0dGFjaG1lbnRzOiBleHBlY3QuYXJyYXlDb250YWluaW5nKFtcbiAgICAgICAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgICAgICAgY29sb3I6ICdkYW5nZXInLFxuICAgICAgICAgICAgICB0aXRsZTogJ0hpZ2ggQ1BVIFVzYWdlJyxcbiAgICAgICAgICAgICAgdGl0bGVfbGluazogJ2h0dHBzOi8vZ3JhZmFuYS5leGFtcGxlLmNvbS9kL2Rhc2hib2FyZC9wYW5lbCcsXG4gICAgICAgICAgICAgIHRleHQ6ICdDUFUgdXNhZ2UgaXMgYWJvdmUgdGhyZXNob2xkJyxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgIF0pLFxuICAgICAgICB9KSxcbiAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aW1lb3V0OiAxMDAwMCxcbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIGV4cGVjdChtb2NrTG9nZ2VyLmluZm8pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAnU2xhY2sgYWxlcnQgc2VudCBzdWNjZXNzZnVsbHknLFxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgcnVsZU5hbWU6ICdIaWdoIENQVSBVc2FnZScsXG4gICAgICAgICAgc3RhdGU6ICdhbGVydGluZycsXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBza2lwIGFsZXJ0IHdoZW4gU2xhY2sgaXMgZGlzYWJsZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBqZXN0LnNweU9uKGNvbmZpZ1NlcnZpY2UsICdzbGFja0VuYWJsZWQnLCAnZ2V0JykubW9ja1JldHVyblZhbHVlKGZhbHNlKTtcblxuICAgICAgYXdhaXQgc2VydmljZS5zZW5kR3JhZmFuYUFsZXJ0KG1vY2tQYXlsb2FkKTtcblxuICAgICAgZXhwZWN0KG1vY2tIdHRwU2VydmljZS5wb3N0KS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgICAgZXhwZWN0KG1vY2tMb2dnZXIuZGVidWcpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAnU2xhY2sgaW50ZWdyYXRpb24gZGlzYWJsZWQsIHNraXBwaW5nIGFsZXJ0J1xuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIG1pc3Npbmcgd2ViaG9vayBVUkwnLCBhc3luYyAoKSA9PiB7XG4gICAgICBqZXN0LnNweU9uKGNvbmZpZ1NlcnZpY2UsICdzbGFja1dlYmhvb2tVcmwnLCAnZ2V0JykubW9ja1JldHVyblZhbHVlKCcnKTtcblxuICAgICAgYXdhaXQgc2VydmljZS5zZW5kR3JhZmFuYUFsZXJ0KG1vY2tQYXlsb2FkKTtcblxuICAgICAgZXhwZWN0KG1vY2tIdHRwU2VydmljZS5wb3N0KS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgICAgZXhwZWN0KG1vY2tMb2dnZXIuZXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAnU2xhY2sgd2ViaG9vayBVUkwgbm90IGNvbmZpZ3VyZWQnXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgSFRUUCBlcnJvcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignTmV0d29yayBlcnJvcicpO1xuICAgICAgbW9ja0h0dHBTZXJ2aWNlLnBvc3QubW9ja1JldHVyblZhbHVlKFxuICAgICAgICBvZigpLnBpcGUoKCkgPT4ge1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9KVxuICAgICAgKTtcblxuICAgICAgYXdhaXQgZXhwZWN0KHNlcnZpY2Uuc2VuZEdyYWZhbmFBbGVydChtb2NrUGF5bG9hZCkpLnJlamVjdHMudG9UaHJvdyhcbiAgICAgICAgJ05ldHdvcmsgZXJyb3InXG4gICAgICApO1xuXG4gICAgICBleHBlY3QobW9ja0xvZ2dlci5lcnJvcikudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICdGYWlsZWQgdG8gc2VuZCBTbGFjayBhbGVydCcsXG4gICAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgICBlcnJvcjogJ05ldHdvcmsgZXJyb3InLFxuICAgICAgICAgIHJ1bGVOYW1lOiAnSGlnaCBDUFUgVXNhZ2UnLFxuICAgICAgICAgIHN0YXRlOiAnYWxlcnRpbmcnLFxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZm9ybWF0IHJlc29sdmVkIGFsZXJ0IGNvcnJlY3RseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc29sdmVkUGF5bG9hZDogR3JhZmFuYVdlYmhvb2tQYXlsb2FkID0ge1xuICAgICAgICAuLi5tb2NrUGF5bG9hZCxcbiAgICAgICAgc3RhdGU6ICdvaycsXG4gICAgICAgIG1lc3NhZ2U6ICdDUFUgdXNhZ2UgaXMgYmFjayB0byBub3JtYWwnLFxuICAgICAgfTtcblxuICAgICAgbW9ja0h0dHBTZXJ2aWNlLnBvc3QubW9ja1JldHVyblZhbHVlKG9mKHsgZGF0YTogeyBvazogdHJ1ZSB9IH0pKTtcblxuICAgICAgYXdhaXQgc2VydmljZS5zZW5kR3JhZmFuYUFsZXJ0KHJlc29sdmVkUGF5bG9hZCk7XG5cbiAgICAgIGV4cGVjdChtb2NrSHR0cFNlcnZpY2UucG9zdCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIGV4cGVjdC5hbnkoU3RyaW5nKSxcbiAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgIHRleHQ6IGV4cGVjdC5zdHJpbmdDb250YWluaW5nKCdPSycpLFxuICAgICAgICAgIGF0dGFjaG1lbnRzOiBleHBlY3QuYXJyYXlDb250YWluaW5nKFtcbiAgICAgICAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgICAgICAgY29sb3I6ICdnb29kJyxcbiAgICAgICAgICAgICAgcHJldGV4dDogZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ09LIEFsZXJ0JyksXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICBdKSxcbiAgICAgICAgfSksXG4gICAgICAgIGV4cGVjdC5hbnkoT2JqZWN0KVxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ3NlbmRDdXN0b21BbGVydCcsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHNlbmQgY3VzdG9tIGFsZXJ0IHN1Y2Nlc3NmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tIdHRwU2VydmljZS5wb3N0Lm1vY2tSZXR1cm5WYWx1ZShvZih7IGRhdGE6IHsgb2s6IHRydWUgfSB9KSk7XG5cbiAgICAgIGF3YWl0IHNlcnZpY2Uuc2VuZEN1c3RvbUFsZXJ0KCdUZXN0IG1lc3NhZ2UnLCAnd2FybmluZycsICcjdGVzdCcpO1xuXG4gICAgICBleHBlY3QobW9ja0h0dHBTZXJ2aWNlLnBvc3QpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAnaHR0cHM6Ly9ob29rcy5zbGFjay5jb20vc2VydmljZXMvdGVzdC93ZWJob29rJyxcbiAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgIGNoYW5uZWw6ICcjdGVzdCcsXG4gICAgICAgICAgdXNlcm5hbWU6ICdWaXNBUEkgU3lzdGVtJyxcbiAgICAgICAgICBpY29uX2Vtb2ppOiAnOnJvYm90X2ZhY2U6JyxcbiAgICAgICAgICB0ZXh0OiAnOndhcm5pbmc6IFRlc3QgbWVzc2FnZScsXG4gICAgICAgICAgYXR0YWNobWVudHM6IGV4cGVjdC5hcnJheUNvbnRhaW5pbmcoW1xuICAgICAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgICAgICBjb2xvcjogJ3dhcm5pbmcnLFxuICAgICAgICAgICAgICB0ZXh0OiAnVGVzdCBtZXNzYWdlJyxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgIF0pLFxuICAgICAgICB9KSxcbiAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aW1lb3V0OiAxMDAwMCxcbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIGV4cGVjdChtb2NrTG9nZ2VyLmluZm8pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAnQ3VzdG9tIFNsYWNrIGFsZXJ0IHNlbnQgc3VjY2Vzc2Z1bGx5JyxcbiAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgIHNldmVyaXR5OiAnd2FybmluZycsXG4gICAgICAgICAgY2hhbm5lbDogJyN0ZXN0JyxcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHVzZSBkZWZhdWx0IGNoYW5uZWwgd2hlbiBub25lIHNwZWNpZmllZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tIdHRwU2VydmljZS5wb3N0Lm1vY2tSZXR1cm5WYWx1ZShvZih7IGRhdGE6IHsgb2s6IHRydWUgfSB9KSk7XG5cbiAgICAgIGF3YWl0IHNlcnZpY2Uuc2VuZEN1c3RvbUFsZXJ0KCdUZXN0IG1lc3NhZ2UnKTtcblxuICAgICAgZXhwZWN0KG1vY2tIdHRwU2VydmljZS5wb3N0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgZXhwZWN0LmFueShTdHJpbmcpLFxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgY2hhbm5lbDogJyNhbGVydHMnLFxuICAgICAgICB9KSxcbiAgICAgICAgZXhwZWN0LmFueShPYmplY3QpXG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgndmFsaWRhdGVXZWJob29rU2lnbmF0dXJlJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcmV0dXJuIHRydWUgZm9yIHZhbGlkIHNpZ25hdHVyZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSAne1widGVzdFwiOiBcImRhdGFcIn0nO1xuICAgICAgY29uc3QgdGltZXN0YW1wID0gJzEyMzQ1Njc4OTAnO1xuICAgICAgY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG4gICAgICBjb25zdCBzaWduYXR1cmUgPSAndjA9JyArIGNyeXB0b1xuICAgICAgICAuY3JlYXRlSG1hYygnc2hhMjU2JywgJ3Rlc3Qtc2VjcmV0JylcbiAgICAgICAgLnVwZGF0ZShgdjA6JHt0aW1lc3RhbXB9OiR7cGF5bG9hZH1gKVxuICAgICAgICAuZGlnZXN0KCdoZXgnKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2VydmljZS52YWxpZGF0ZVdlYmhvb2tTaWduYXR1cmUocGF5bG9hZCwgdGltZXN0YW1wLCBzaWduYXR1cmUpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gZmFsc2UgZm9yIGludmFsaWQgc2lnbmF0dXJlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcGF5bG9hZCA9ICd7XCJ0ZXN0XCI6IFwiZGF0YVwifSc7XG4gICAgICBjb25zdCB0aW1lc3RhbXAgPSAnMTIzNDU2Nzg5MCc7XG4gICAgICBjb25zdCBzaWduYXR1cmUgPSAndjA9aW52YWxpZF9zaWduYXR1cmUnO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzZXJ2aWNlLnZhbGlkYXRlV2ViaG9va1NpZ25hdHVyZShwYXlsb2FkLCB0aW1lc3RhbXAsIHNpZ25hdHVyZSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gdHJ1ZSB3aGVuIG5vIHNpZ25pbmcgc2VjcmV0IGlzIGNvbmZpZ3VyZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBqZXN0LnNweU9uKGNvbmZpZ1NlcnZpY2UsICdzbGFja1NpZ25pbmdTZWNyZXQnLCAnZ2V0JykubW9ja1JldHVyblZhbHVlKCcnKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2VydmljZS52YWxpZGF0ZVdlYmhvb2tTaWduYXR1cmUoJ3BheWxvYWQnLCAnMTIzJywgJ3NpZycpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KG1vY2tMb2dnZXIud2FybikudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICdTbGFjayBzaWduaW5nIHNlY3JldCBub3QgY29uZmlndXJlZCwgc2tpcHBpbmcgc2lnbmF0dXJlIHZhbGlkYXRpb24nXG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcbn0pOyJdLCJ2ZXJzaW9uIjozfQ==